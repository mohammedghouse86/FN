directive @fetch(from: String!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @Max(value: Int! = 2147483647, message: String = "graphql.validation.Max.message") on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Min(value: Int! = 0, message: String = "graphql.validation.Min.message") on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @Range(min: Int = 0, max: Int = 2147483647, message: String = "graphql.validation.Range.message") on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @hasRole(role: String = "ADMIN", isOrgOperationAllowed: Boolean = false) on FIELD_DEFINITION

input AIAgentStepInput {
  next: String
  sessionId: String
  prompt: String
  tenantId: String
  steps: [ApiResolverStepInput]
  modelType: AIModelType
  model: String
  memory: StorageLocation
  connectorId: String
  sessionMemoryTableName: String
  sessionMemoryContentLimit: Int
}

type AIAgentStepOutput {
  next: String
  sessionId: String
  prompt: String
  tenantId: String
  steps: [ApiResolverStepOutput]
  modelType: AIModelType
  model: String
  memory: StorageLocation
  connectorId: String
  sessionMemoryTableName: String
  sessionMemoryContentLimit: Int
}

enum AIModelType {
  OPEN_AI
  DEEPSEEK
  GEMINI
}

enum APIArchitecture {
  REST
  GRAPHQL
  GENERIC
}

enum AccessRole {
  READ
  WRITE
  MAINTAIN
  ADMIN
}

input ActionContractInput {
  request: ContractInput
  success: ContractInput
  failure: ContractInput
}

input ActionContractInputRequest {
  clientId: String!
  id: String!
  contract: ActionContractInput!
}

type ActionContractOutput {
  request: ContractOutput
  success: ContractOutput
  failure: ContractOutput
}

type ActionContractOutputRequest {
  clientId: String!
  id: String!
  contract: ActionContractOutput
}

input ActivateConnectorStateInput {
  key: String
  value: JSON!
}

type ActivateConnectorStateOutput {
  key: String
  value: JSON
}

input AddApiDependencyInput {
  id: String!
  clientId: String!
  dependency: ApiResolverStepInput!
}

type AddApiDependencyOutput {
  id: String!
  clientId: String!
  dependency: ApiResolverStepOutput!
}

input AddApiTestsInput {
  id: ID!
  clientId: ID!
  tests: [ApiTestCaseInput]
}

input AddDataSourceToGroupInput {
  id: String!
  name: String!
  groupId: String!
}

type AddDataSourceToGroupOutput {
  id: String!
  name: String!
  groupId: String!
}

input AddFlowTemplateInput {
  clientId: String!
  template: ApiTemplatesInput
}

input AddRecordsInput {
  clientId: String!
  tableName: String!
  records: [[KeyValInput]!]!
}

input AggregateFieldInput {
  fieldName: String
  renameFieldName: String
  enableRename: Boolean
}

type AggregateFieldOutput {
  fieldName: String
  renameFieldName: String
  enableRename: Boolean
}

enum AggregateFieldsStrategy {
  ALL
  INCLUDES_ONLY
  EXCLUDES_ONLY
}

enum AggregateStrategy {
  ALL_FIELDS
  INDIVIDUAL_FIELDS
}

input AiActionStepInput {
  next: String
  sessionId: String
  prompt: String
  tenantId: String
}

type AiActionStepOutput {
  next: String
  sessionId: String
  prompt: String
  tenantId: String
}

enum ApiActionType {
  CREATE
  READ
  UPDATE
  DELETE
  SEARCH
}

input ApiAutocompleteInput {
  type: AutocompleteSource!
  clientId: String!
  sourceId: String!
  inputName: String
}

input ApiBuildInput {
  clientId: String!
  name: String!
  description: String
  actionType: ApiActionType
  inputName: String
  inputModelId: String
  outputModelId: String!
  errorModelId: String
}

input ApiConnectPrimaryResolverInput {
  id: ID!
  clientId: ID!
  label: String
  groupId: String
  type: String!
  dependencies: [ApiResolverStepInput!]
  steps: [ApiResolverStepInput!]!
}

input ApiConnectSecondaryResolverInput {
  id: ID!
  label: String
  clientId: ID!
  groupId: String
  type: String!
  field: String!
  steps: [ApiResolverStepInput!]!
}

type ApiConnection {
  edges: [ApiEdge!]!
  pageInfo: PageInfo!
}

input ApiDebugConfigInput {
  loopExecutionTimes: Int
  enable: Boolean
}

type ApiDependencyList {
  id: String!
  clientId: String!
  total: Int!
  dependencies: [ApiResolverStepOutput]
}

type ApiEdge {
  cursor: String!
  node: ApiOutput!
}

enum ApiField {
  CODE
  BODY
  CUSTOM
}

input ApiInput {
  uri: UriInput!
  method: HttpMethod!
  headers: [HeaderInput]!
  body: String
}

type ApiKey {
  id: String!
  name: String
  allowedOrigins: [String]
  allowedTenants: [String!]
  apiScopes: [String]
  webhookScopes: [String]
  workflowScopes: [String]
  expiresAt: String
  lastDigits: String
}

input ApiKeyInput {
  id: String
  projectId: String!
  name: String!
  apiScopes: [String]
  webhookScopes: [String]
  workflowScopes: [String]
  allowedOrigins: [String]
  allowedTenants: [String!]
  expiresAt: String
}

type ApiKeysConnection {
  edges: [ApiKeysEdge!]!
  pageInfo: PageInfo!
}

type ApiKeysEdge {
  cursor: String!
  node: ApiKeysOutput!
}

type ApiKeysOutput {
  id: ID!
  name: String!
  expiresAt: String
  lastDigits: String
  allowedTenants: [String!]
}

input ApiMetaDataInput {
  enableLogs: Boolean
  isAsync: Boolean
  hasSecret: Boolean
  enableValidation: Boolean
  enableMultitenant: Boolean
  hasNewConfiguration: Boolean
  architecture: APIArchitecture
  isCustomAuthenticationEnabled: Boolean
  isNotificationEnabled: Boolean
  jobMemoryLimit: Int
  jobTimeOut: Int
  jobCpuLimit: String
  flowType: FlowType
  configurationFlows: [FlowTenantSettingsInput]
  invocationMethod: FlowInvocationMethod
  priority: PriorityLevel
}

type ApiMetaDataOutput {
  enableLogs: Boolean
  isAsync: Boolean
  hasSecret: Boolean
  enableMultitenant: Boolean
  hasNewConfiguration: Boolean
  flowType: FlowType
  enableValidation: Boolean
  architecture: APIArchitecture
  isCustomAuthenticationEnabled: Boolean
  isNotificationEnabled: Boolean
  jobMemoryLimit: Int
  jobCpuLimit: String
  jobTimeOut: Int
  configurationFlows: [FlowTenantSettingsOutput]
  invocationMethod: FlowInvocationMethod
  priority: PriorityLevel
}

type ApiOutput {
  id: ID!
  clientId: String!
  name: String!
  version: String
  description: String
  actionType: ApiActionType
  hasActionType: Boolean
  outputModelId: String!
  errorModelId: String
  headerModelId: String
  inputName: String
  inputModelId: String
  apiPreview: ApiPreviewOutput
  outputModel: DataModelOutput
  errorModel: DataModelOutput
  inputModel: DataModelOutput
  headerModel: DataModelOutput
  status: ApiStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  deployedAt: DateTime
  webhookId: String
  dependencySchema: DependencySchemaOutput
  resolver: ConnectPrimaryResolverOutput
  chatWelcomeMessage: String
  comment: String
  types: [TypesOutput]
  tests: [ApiTestCaseInputOutput]
  metaData: ApiMetaDataOutput
  labels: [String]
  deleted: Boolean
}

input ApiPreviewInput {
  clientId: String!
  name: String!
  actionType: ApiActionType!
  outputModelId: String!
  inputName: String
  inputModelId: String
}

type ApiPreviewOutput {
  graphql: GraphQlPreviewOutput
  rest: RestPreviewOutput
}

input ApiPrimaryResolverInvocationInput {
  id: String!
  clientId: String!
  input: JSON
  setting: ApiDebugConfigInput
}

input ApiResolverStepInput {
  type: StepType!
  id: String!
  enableDebug: Boolean
  description: String
  actionId: String
  debugBreakAfter: Int
  imageUrl: String
  outputSchema: String
  next: String
  inline: InlineStepInput
  function: FunctionStepInput
  composite: CompositeStepInput
  conditional: ConditionalStepInput
  loop: LoopStepInput
  logger: LoggerStepInput
  endLoop: EndLoopingStepInput
  variables: VariablesStepInput
  internalDatabase: InternalDatabaseStepInput
  downLoadFile: DownLoadFileInput
  converter: ConverterStepInput
  trigger: TriggerStepInput
  filter: DataTransformationStepInput
  limit: DataTransformationStepInput
  splitOut: DataTransformationStepInput
  aiAction: AiActionStepInput
  aiAgent: AIAgentStepInput
  mcpClient: McpClientStepInput
  aggregate: DataTransformationStepInput
  merge: DataTransformationStepInput
  lambdaFunction: LambdaFunctionInput
  state: StateStepInput
  tenantSettings: FlowTenantSettingsInput
  configuredStepSetting: ConfiguredStepSettingInput
  settings: StepSettingInput
  ftp: FtpStepInput
}

type ApiResolverStepOutput {
  type: StepType!
  id: String!
  enableDebug: Boolean
  description: String
  actionId: String
  debugBreakAfter: Int
  outputSchema: String
  inline: InlineStepOutput
  function: FunctionStepOutput
  composite: CompositeStepOutput
  conditional: ConditionalStepOutput
  loop: LoopStepOutput
  converter: ConverterStepOutput
  endLoop: EndLoopingStepOutput
  variables: VariablesStepOutput
  state: StateStepOutput
  trigger: TriggerStepOutput
  logger: LoggerStepOutput
  internalDatabase: InternalDatabaseStepOutput
  downLoadFile: DownLoadFileOutput
  lambdaFunction: LambdaFunctionOutput
  filter: DataTransformationStepOutput
  limit: DataTransformationStepOutput
  splitOut: DataTransformationStepOutput
  aggregate: DataTransformationStepOutput
  merge: DataTransformationStepOutput
  aiAction: AiActionStepOutput
  aiAgent: AIAgentStepOutput
  mcpClient: McpClientStepOutput
  next: String
  warnings: JSON
  tenantSettings: FlowTenantSettingsOutput
  configuredStepSetting: ConfiguredStepSetting
  settings: StepSetting
  ftp: FtpStepOutput
}

"""
mutation {
connectApiType(input: {
clientId: "1",
id: "1",
fieldName: "test",

})
"""
input ApiResponseMappingInput {
  clientId: String!
  id: String!
}

input ApiSchemaInput {
  host: String
  uri: String
  method: HttpMethod
  headers: [KeyValInput]
  params: [KeyValInput]
  request: [ResponseAndRequestContent]
  response: [DataSourceSchemaResponseInput]
}

enum ApiStatus {
  CONNECT
  PUBLISH
  DEPLOYED
}

input ApiTemplatesInput {
  id: String!
  clientId: String!
  userId: String!
  flowId: String!
  title: String!
  scope: String!
  description: String
  data: JSON
  type: FlowType
  uiId: String!
  orgId: String
  labels: [TemplateLabels]
}

input ApiTestCaseInput {
  name: String!
  description: String
  given: GivenInput!
  then: ThenInput!
}

type ApiTestCaseInputOutput {
  name: String!
  description: String
  given: GivenOutput!
  then: ThenOutput!
}

type ApiTestCaseOutput {
  name: String!
  description: String
  message: String!
  result: TestResult!
  conditions: [ConditionOutput!]!

  """TODO change this to a more generic type"""
  response: JSON!
}

type ApiTestCaseSuiteOutput {
  tests: [ApiTestCaseOutput]
}

input ApiUpdateBuildInput {
  id: String!
  clientId: String!
  name: String!
  description: String
  actionType: ApiActionType
  inputName: String
  inputModelId: String
  outputModelId: String!
  errorModelId: String
  headerModelId: String
  metaData: ApiMetaDataInput
  labels: [String]
  webhookId: String
  chatWelcomeMessage: String
  webhook: CreateWebhookWithRoutsInput
}

type AppTriggerAccountOutput {
  email: String!
  id: String!
}

input AppTriggerAccountsInput {
  clientId: String!
  connectorId: String!
}

type AppTriggerAccountsOutput {
  accounts: [AppTriggerAccountOutput]
}

input AppTriggerEventInput {
  id: String
  label: String
  description: String
}

type AppTriggerEventOutput {
  id: String
  label: String
  description: String
}

type AppTriggerEventsConnection {
  edges: [AppTriggerEventsEdge!]!
  pageInfo: PageInfo!
}

type AppTriggerEventsEdge {
  cursor: String!
  node: AppTriggerEventsOutput!
}

input AppTriggerEventsInput {
  triggerId: String!
  name: String
  imageUrl: String
  events: [AppTriggerEventInput]
}

type AppTriggerEventsOutput {
  triggerId: String
  name: String
  imageUrl: String
  events: [AppTriggerEventOutput]
}

type AppTriggerOutput {
  id: String!
  clientId: String!
  triggerId: String
  userAccountId: String
  flowId: String
  connectorId: String
  event: String
  tenantId: String
  connectorName: String
  connectorImage: String
  payload: JSON
  headers: [HeaderOutput]
  type: AppTriggerType
}

enum AppTriggerType {
  BUILD_TIME
  FIXED
  CUSTOM
}

type AppTriggersConnection {
  edges: [AppTriggersEdge!]!
  pageInfo: PageInfo!
}

type AppTriggersEdge {
  cursor: String!
  node: AppTriggerOutput!
}

type ApplicationOutput {
  id: String
  name: String
  paymentStatus: String
  paymentReferenceId: String
  role: String
  lagoKey: String
  email: String
}

enum ApplicationType {
  connectorsWidget
  copilotApp
}

input AssignRoleToUserInput {
  email: String!
  role: UserRoles!
  projectId: String
}

type AuthConfig {
  authKey: String
  authValue: String
  bearerToken: String
}

enum AuthMethod {
  BASIC
  BEARER
  APIKEY
  NO_AUTH
}

enum AuthType {
  BASIC
  BEARER
  JWT_BEARER
  AWS_SIGNATURE
  APIKEY
  OAUTH1
  OAUTH2
  NO_AUTH
  OAUTH
  INPUT
}

enum AutocompleteSource {
  REQUEST
  RESPONSE
}

input BuildApiDraftInput {
  clientId: String!
  name: String!
  actionType: ApiActionType
  metaData: ApiMetaDataInput
  webhookId: String
  webhook: CreateWebhookWithRoutsInput
}

type BuildApiDraftOutput {
  name: String!
  id: String!
  clientId: String!
}

input BuildJsonSchemaInput {
  json: String
}

type BuildJsonSchemaOutput {
  output: String
}

input CloneDataModelInput {
  name: String!
  clientId: String!
  modelId: String!
}

input CloneResolverStep {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
}

type CodeExample {
  name: String!
  description: String
  code: String
}

input CodeResponseSchema {
  schema: String
}

type ColumnInfo {
  name: String!
  type: String!
  required: Boolean
  unique: Boolean
  isArray: Boolean
  index: Boolean
  defaultValue: String
  primary: Boolean
}

input ColumnInfoInput {
  name: String!
  type: String
  required: Boolean
  unique: Boolean
  isArray: Boolean
  index: Boolean
  defaultValue: String
  primary: Boolean
}

input CommunityDataTypeInput {
  name: String!
  jsonSchema: JSON
  uiSchema: JSON
  groupId: String!
}

input CompileInput {
  code: String!
  language: Language!
  context: JSON
}

input CompositeStepInput {
  steps: [ApiResolverStepInput!]!
  next: String
}

type CompositeStepOutput {
  steps: [ApiResolverStepOutput!]!
  next: String
}

type ConditionOutput {
  expected: String!
  actual: String!
  path: String
  match: Match!
}

input ConditionalDataSourceInput {
  condition: String
  dataSource: String
}

input ConditionalExpressionInput {
  name: String
  variable: String
  operation: Match
  value: String
  conditions: [ConditionalExpressionInput!]
  logic: LogicType
  next: String
}

type ConditionalExpressionOutput {
  name: String
  operation: Match
  variable: String
  value: String
  logic: LogicType
  conditions: [ConditionalExpressionOutput!]
  next: String
}

input ConditionalStepInput {
  id: String
  expressions: [ConditionalExpressionInput!]
  next: String
}

type ConditionalStepOutput {
  expressions: [ConditionalExpressionOutput!]
  next: String
}

input ConfigurationLayerMapperInput {
  source: ID!

  """ Id of the source"""
  mapper: String!
}

type ConfigurationLayerOutput {
  source: ID!

  """ Id of the source"""
  mapper: String!
}

type ConfigurationSubscription {
  connector: Connector
  status: ConfigurationSubscriptionStatus
  metaData: JSON
}

input ConfigurationSubscriptionInput {
  clientId: String!
  tenantId: String!
  id: String!
  status: ConfigurationSubscriptionStatus
}

enum ConfigurationSubscriptionStatus {
  ENABLED
  DISABLED
  IDLE
  ALL
}

type ConfigurationsOutput {
  env: String!
  data: JSON
}

input ConfigureTenantFlowInput {
  clientId: String!
  flowId: String!
  tenantId: String!
  isConfigured: Boolean
  connectorId: String!
  resolver: ConnectPrimaryResolverInput
}

type ConfiguredAddButtonSetting {
  label: String
  isDisabled: Boolean
  fieldsLimit: String
}

input ConfiguredAddButtonSettingInput {
  label: String
  isDisabled: Boolean
  fieldsLimit: String
}

type ConfiguredStepSetting {
  keyIsEditable: Boolean
  addButton: ConfiguredAddButtonSetting
  description: String
  label: String
  enableMultiConfigs: Boolean
  validation: StepValidation
}

input ConfiguredStepSettingInput {
  keyIsEditable: Boolean
  addButton: ConfiguredAddButtonSettingInput
  description: String
  label: String
  enableMultiConfigs: Boolean
  validation: StepValidationInput
}

input ConnectConfigInput {
  userName: String
  password: String
  host: String
  databaseName: String
  clientId: String
}

type ConnectConfigOutput {
  userName: String
  password: String
  host: String
  databaseName: String
}

input ConnectDbInput {
  connectionId: String
  clientId: String
}

type ConnectDbOutput {
  tables: [PostgresTablesContent]
}

input ConnectPrimaryResolverInput {
  """ID of the API"""
  id: ID!
  clientId: ID!
  label: String
  groupId: String
  type: String
  field: String
  steps: [ApiResolverStepInput!]!
  start: String
}

type ConnectPrimaryResolverOutput {
  """ID of the API"""
  id: ID!
  clientId: ID!
  label: String
  groupId: String
  type: String!
  field: String!
  dependencies: [ApiResolverStepOutput!]
  steps: [ApiResolverStepOutput!]!
  start: String
}

input ConnectResolverStepsInput {
  id: String!
  clientId: String!
  source: String
  target: String
  sourceIsDefault: Boolean
  sourceExpressionIndex: Int
  parentIds: [String]
}

input ConnectedConnectorsInput {
  orgId: String!
  id: String!
  isPrimary: Boolean
  authAttributes: JSON
}

type Connector {
  id: ID!
  name: String!
  description: String
  imageUri: String
  updatedAt: DateTime
  actions: [ConnectorAction]
  events: [ConnectorEvent]
  connectedConnectors: [GroupsOutput]
  status: ConnectorStatus
  content: String
  active: Boolean
  deployed: Boolean
  tenantScope: [String]
  isTenantScopeEnabled: Boolean
  connectionId: String
  deleted: Boolean
  statuses: [ConnectorStatus]
  middlewareFlowData: JSON
  widgetType: WidgetType
  starterActions: [StarterAction]
  images: [String]
  dataFlowLabel: DataFlowLabel
  isPrimary: Boolean
  inputValidation: JSON
  labels: [String]
}

type ConnectorAction {
  name: String!
  handler: String
  activatedStateLabel: String
  shows: ShowWidgetConnectorActions
  content: String
  handlerPayload: JSON
  actionType: ConnectorActionType
  multiConnectorWidgetConnectors: [Connector!]
}

input ConnectorActionInput {
  name: String!
  handler: String
  activatedStateLabel: String
  shows: ShowWidgetConnectorActions
  content: String
  actionType: ConnectorActionType
  handlerPayload: JSON
  multiConnectorWidgetConnectors: [MultiConnectorWidgetConnectorInput!]
}

enum ConnectorActionType {
  ACTIVATION
  CONFIGURATION
  DEACTIVATION
  MULTI_CONNECTOR
  NONE
}

type ConnectorAuthMethod {
  type: AuthType
  details: JSON
  title: String
  inputContract: JSON
  isDefault: Boolean
}

input ConnectorAuthMethodInput {
  type: AuthType
  details: JSON
  title: String
  inputContract: JSON
  secret: String
  isDefault: Boolean
}

input ConnectorConnectionInput {
  projectId: String
  tenantId: String
  connectorId: String!
  orgId: String!
  refresh: Boolean
}

type ConnectorEvent {
  name: String!
  eventId: String!
  content: String
  payload: String
}

input ConnectorEventInput {
  name: String!
  eventId: String!
  content: String
  payload: String
}

enum ConnectorStatus {
  ACTIVE
  CONFIGURED
  INACTIVE
}

type ConnectorsStatsData {
  total_error: Int
  total_success: Int
  group_id: String
  connector_id: String
  groupName: String
  image: String
  startat: String
}

type ConsumerStats {
  groupId: String!
  pending: Int!
  processed: Int!
  failed: Int!
  missed: Int
}

enum ContentTypeOutput {
  TEXT_PLAIN
  TEXT_HTML
  APPLICATION_JSON
  APPLICATION_XML
  APPLICATION_X_WWW_FORM_URLENCODED
  MULTIPART_FORM_DATA
}

input ContextDetails {
  targetField: String
  schema: String!
  alias: String = ""
  type: SCHEMA_TYPE = JSON
}

input ContractInput {
  schema: String
  uiSchema: String
}

type ContractOutput {
  schema: String
  uiSchema: String
}

input ContractVariableInput {
  name: String!
  value: String
}

type ContractVariableOutput {
  name: String
  value: String
}

input ConverterStepInput {
  next: String
  source: String
  type: ConverterType
}

type ConverterStepOutput {
  next: String
  source: String
  type: ConverterType
}

enum ConverterType {
  JSON_PARQUET
}

input CreateAppTriggerInput {
  id: String
  triggerId: String
  clientId: String!
  userAccountId: String!
  flowId: String!
  connectorId: String!
  tenantId: String
  event: String!
  connectorName: String
  connectorImage: String
  headers: [HeaderInput]
  type: AppTriggerType
}

type CreateConfigurationsOutput {
  clientId: String!
  name: String
}

input CreateConnectorInput {
  projectId: String!
  id: String
  name: String
  description: String
  imageUri: String
  actions: [ConnectorActionInput]
  events: [ConnectorEventInput]
  connectedConnectors: [ConnectedConnectorsInput]
  connectorId: String
  content: String
  active: Boolean
  tenantScope: [String]
  isTenantScopeEnabled: Boolean
  widgetType: WidgetType
  starterActions: [StarterActionInput!]
  images: [String!]
  dataFlowLabel: DataFlowLabel
  labels: [String]
}

input CreateDataSourceInput {
  clientId: String!
  name: String!
  description: String
  host: String!
  uri: String!
  category: String
  logo: String
  method: HttpMethod!
  headers: [HeaderInput]!
  body: String
  query: String
  params: [ParamInput]!
  testCaseId: String
  enabled: Boolean!
  requestDataType: DataSourceDataTypeInput
  responseDataType: DataSourceDataTypeInput
  responsesSchema: [ResponseSchemaInput]
  requestSchema: ResponseSchemaInput
  isPaginated: Boolean!
  pagination: PaginationInput
  variables: JSON
  type: DataSourceTemplatePatternType
}

"""Input for the createDataSource mutation"""
type CreateDataSourceOutput {
  dataSource: DataSource!
  id: ID!
  clientId: String!
  name: String!
  description: String
  category: String
  logo: String
  host: String!
  uri: String!
  method: HttpMethod!
  headers: [HeaderOutput]!
  body: String
  query: String
  params: [ParamOutput]!
  enabled: Boolean!
  testCaseId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  variables: JSON
  type: DataSourceTemplatePatternType

  """
  Use cases:
  1. User creates the datatype on the UI
  2. User sends an already created datatype
  """
  requestDataType: DataTypeEntity!
  responseDataType: DataTypeEntity
  responsesSchema: [ResponseSchema]
  isPaginated: Boolean
  pagination: PaginationOutput
}

input CreateEnvConfigsInput {
  projectId: String!
  configs: [EnvConfigsListInput]
}

input CreateEnvConfigurationInput {
  clientId: String!
  env: String!
  data: JSON
}

input CreateFunctionInput {
  clientId: String!
  name: String!
  code: String
}

input CreateInputInput {
  clientId: String!
  features: FeaturesFlagInput!
}

input CreateLabelInput {
  id: String!
  clientId: String!
  orgId: String
  name: String!
  type: LabelType!
}

input CreateModelGroupInput {
  clientId: String!
  name: String
  imageUrl: String
  type: DataModelType!
  description: String
  docLink: String
  tags: [String]
  isOauth: Boolean
  oauthSecret: String
  oauth: JSON
  oauthInputContract: JSON
  enableActivate: Boolean
  resourceType: ResourceType
  labels: [String]
  authMethods: [ConnectorAuthMethodInput]
}

input CreateModelSchemaInput {
  clientId: String!
  name: String!
  description: String
  version: String
  model: UpdatedDataTypeInput
  input: UpdatedDataTypeInput
  actionType: ApiActionType
  inputName: String = "input"
  schema: String
  remote: RemoteInput
  types: [ModelTypeInput]
  tests: [ApiTestCaseInput]
}

input CreateProxyInput {
  clientId: String!
  name: String
  version: String!
  description: String
  logo: String
  url: String
  proxyUrl: String
  registeredApis: [String]
  introspectionUrl: String

  """Variables for the proxy"""
  variables: JSON

  """Additional info, includes the template id"""
  additionalInfo: JSON
}

input CreateResolverStepInput {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
  expression: Int
  isDefault: Boolean
  newNodeId: String
  step: ApiResolverStepInput!
}

input CreateSecretsInput {
  clientId: String!
  discriminator: String
  secrets: [SecretsInput]
}

input CreateSyndicationInput {
  clientId: String!
  name: String!
  description: String
  indexName: String
  entityName: String
  syndicationConfiguration: SyndicationConfigurationInput
  sinkDatasourceId: String
  transformation: LdTemplatedValueInput
  additionalInfo: JSON
}

input CreateTeamInput {
  email: String!
  name: String!
  parentTeamId: String
}

input CreateUserFeaturesInput {
  userId: String!
  features: FeaturesFlagInput!
}

input CreateWebhookRouteInput {
  id: String!
  appId: String!
  routeId: String!
  description: String!
  apiId: String!
  batchSize: Int
  maximumBatchingWindow: Int
  filters: [WebhookRoutesFilterInput]
  headers: [HeaderInput]
}

type CreateWebhookRouteOutput {
  id: String!
}

input CreateWebhookScheduleInput {
  webhookId: String!
  appId: String!
  schedule: ScheduleInput
}

input CreateWebhookWithRoutesRouteInput {
  routeId: String!
  flowId: String!
  filters: [WebhookRoutesFilterInput]
  headers: [HeaderInput]
  batchSize: Int
  maximumBatchingWindow: Int
}

input CreateWebhookWithRoutsBatchInput {
  webhookName: String!
  webhookId: String
  apiKey: String
  dlqConfigurations: DLQConfigurationInput
  sqsConfigurations: SqsConfigurationInput
  isAuthenticated: Boolean
  autoGenerateApiKey: Boolean
  routes: [CreateWebhookWithRoutesRouteInput]
  schedule: ScheduleBatchInput
  action: ImportAction
  webhookType: WebhookType
}

input CreateWebhookWithRoutsInput {
  projectId: String!
  webhookName: String!
  webhookId: String
  apiKey: String
  webhookType: WebhookType
  dlqConfigurations: DLQConfigurationInput
  sqsConfigurations: SqsConfigurationInput
  isAuthenticated: Boolean
  autoGenerateApiKey: Boolean
  routes: [CreateWebhookWithRoutesRouteInput]
  schedule: ScheduleInput
  action: ImportAction
}

input CreateWebhooksWithRoutsBatchInput {
  projectId: String!
  webhooks: [CreateWebhookWithRoutsBatchInput]!
}

input CreateWorkflowInput {
  clientId: String!
  name: String!
  description: String
  imageUrl: String
  startStep: String!
  contract: ActionContractInput
  steps: [WorkflowStepInput!]!
}

type CurlOutput {
  headers: [HeaderOutput]
  url: String
  httpMethod: HttpMethod
  params: [ParamOutput]
  body: String
  inputSchema: String
  outputSchema: String
  authConfig: AuthConfig
  authMethod: AuthMethod
  output: String
  error: CurlRequestError
  errorMessage: String
}

enum CurlRequestError {
  """Request timed out."""
  TIMEOUT

  """Error executing the request."""
  EXECUTION
}

input CurlRequestInput {
  command: String!
  template: Boolean
  templateHeaders: Boolean
  shouldExecute: Boolean
}

type CustomPlan {
  workflowLimit: Int!
  apiLimit: Int!
  apiStepLimit: Int!
  apiKeyLimit: Int!
  webhookLimit: Int!
  webhookRouteLimit: Int!
  appMemberLimit: Int!
  datasourceCacheLimit: Int!
  queuePriority: Int!
  jobLimit: Int!
  jobPeriod: Int!
  apiRequestLimit: Int!
  databaseTableLimit: Int!
  databaseSchemaSizeLimit: Int!
  storageLocation: String
  throttlingTime: Int
  flowStepsExecutionLimit: Int
  statementTimes: Int
  autoEscape: String
}

input CustomPlanInput {
  workflowLimit: Int!
  apiLimit: Int!
  apiStepLimit: Int!
  apiKeyLimit: Int!
  webhookLimit: Int!
  webhookRouteLimit: Int!
  appMemberLimit: Int!
  datasourceCacheLimit: Int!
  queuePriority: Int!
  jobLimit: Int!
  jobPeriod: Int!
  apiRequestLimit: Int!
  databaseTableLimit: Int!
  databaseSchemaSizeLimit: Int!
  storageLocation: String
  throttlingTime: Int
  flowStepsExecutionLimit: Int
  statementTimes: Int
  autoEscape: String
}

input DBQueryParamInput {
  type: String
  value: JSON
}

type DBQueryParamOutput {
  type: String
  value: JSON
}

input DLQConfigurationInput {
  numberOfRetries: Int
  isEnabled: Boolean
}

type DLQConfigurationOutput {
  numberOfRetries: Int
  isEnabled: Boolean
}

type DashboardOutput {
  traffic: String
  errors: String
  latency: String
  endpoints: String
  dataSources: String
  models: String
}

enum DataFlowLabel {
  INBOUND
  OUTBOUND
  BI_DIRECTIONAL
}

input DataModelByGroupInput {
  clientId: String!
  group: String!
  groupType: DataModelType
  first: Int! = 10
  after: String
  query: String
}

type DataModelConnection {
  edges: [DataModelEdge!]!
  pageInfo: PageInfo!
}

type DataModelEdge {
  cursor: String!
  node: DataTypeEntity!
}

type DataModelOutput {
  id: ID
  name: String
  clientId: String
  type: String
  version: String
  jsonSchema: JSON
  groupId: String
  isCommunityCreated: Boolean
}

input DataModelPreviewInput {
  jsonSchema: JSON
  name: String
}

type DataModelTemplate {
  id: ID!
  name: String!
  imageUrl: String
  description: String
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  isCommunityCreated: Boolean!
  badges: [String!]!
  connectors: [LabeledImage!]!
  features: [KeyValue!]!
  supportedOperations: [SupportedOperation]
  dataModel: JSON
  preview: ModelPreview
}

enum DataModelType {
  MODEL
  TEMPLATE_MODEL_GROUP
  USER_MODEL_GROUP
  TEMPLATE_DATA_SOURCE_GROUP
  USER_DATA_SOURCE_GROUP
}

type DataSource {
  id: ID!
  clientId: String!
  name: String!
  description: String
  host: String!
  uri: String!
  method: HttpMethod!
  headers: [HeaderOutput]!
  body: String
  query: String
  params: [ParamOutput]!
  enabled: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  variables: JSON
}

type DataSourceConnection {
  edges: [DataSourceEdge!]!
}

"""
{name}:{version} is the unique identifier for the datatype
TODO see how we can reuse datatype input types
"""
input DataSourceDataTypeInput {
  id: String
}

type DataSourceEdge {
  node: DataSourcePayload!
}

"""Input for the createDataSource mutation"""
type DataSourcePayload {
  id: ID!
  clientId: String!
  name: String!
  description: String
  category: String
  logo: String
  host: String!
  uri: String!
  method: HttpMethod!
  headers: [HeaderOutput]!
  body: String
  query: String
  params: [ParamOutput]!
  testCaseId: String
  enabled: Boolean!
  testCaseSuite: TestCaseOutPut
  variables: JSON
  type: DataSourceTemplatePatternType
  createdAt: DateTime!
  updatedAt: DateTime!
  requestDataType: DataTypeEntity
  responseDataType: DataTypeEntity
  responsesSchema: [ResponseSchema]
  isPaginated: Boolean
  pagination: PaginationOutput
}

input DataSourceSchemaResponseInput {
  code: Int
  content: [ResponseAndRequestContent]
}

input DataSourceSpecInput {
  dataSource: ApiSchemaInput
  type: DataSourceSpecInputType
  value: String
  action: ActionContractInput
}

enum DataSourceSpecInputType {
  OPEN_API
  DATASOURCE
  FUNCTION @deprecated(reason: "Use ACTION instead")
  ACTION
}

type DataSourceSpecOutput {
  type: DataSourceSpecInputType
  value: String
  action: ActionContractOutput
}

type DataSourceTemplate {
  id: ID!
  clientId: ID
  name: String!
  version: String
  description: String
  imageUrl: String
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  isCommunityCreated: Boolean!
  badges: [String!]!
  connectors: [LabeledImage!]!
  features: [KeyValue!]!
  variables: JSON
  ConnectionSchemaInput: JSON
  type: DataSourceTemplatePatternType
  pagination: PaginationOutput
  dataSource: JSON
  contract: DataSourceSpecOutput
  contractVariables: [ContractVariableOutput]
  code: String
}

type DataSourceTemplateConnection {
  edges: [DataSourceTemplateEdge!]!
  pageInfo: PageInfo!
}

type DataSourceTemplateEdge {
  cursor: String!
  node: DataSourceTemplatePattOutput!
}

input DataSourceTemplateInput {
  context: JSON!
}

type DataSourceTemplateMetadata {
  responseSchemaCreated: Boolean
}

type DataSourceTemplateOutput {
  context: JSON!
}

type DataSourceTemplatePattOutput {
  id: ID!
  clientId: ID!
  name: String!
  version: String
  contract: DataSourceSpecOutput
  contractVariables: [ContractVariableOutput]
  imageUrl: String
  type: DataSourceTemplatePatternType

  """For functions"""
  code: String
  connectorId: String
  groupId: String
  isCommunityCreated: Boolean!
  configurationLayer: ConfigurationLayerOutput
  createdAt: DateTime
  updatedAt: DateTime
  nested(field: String!): FieldSchemaOutput
  metadata: DataSourceTemplateMetadata
  labels: [String]
}

input DataSourceTemplatePatternInput {
  id: ID
  clientId: ID!
  name: String!
  contract: DataSourceSpecInput
  contractVariables: [ContractVariableInput]!
  isConfiguration: Boolean
  configurationLayer: ConfigurationLayerMapperInput

  """For functions"""
  code: String
  connectorId: String
  groupId: String
  imageUrl: String
  isCommunityCreated: Boolean! = false
  connectionSchemaString: String

  """Datasource type: fn, api, db, etc."""
  type: DataSourceTemplatePatternType
}

enum DataSourceTemplatePatternType {
  DB
  CONNECTION
  API
  FUNCTION
  ALL
  CUSTOM
}

type DataSourceTestPayload {
  clientId: String!
  response: RequestResponse!
  generatedDataTypes: GeneratedDataType
  transformation: JSON
}

enum DataSourceType {
  HTTP
  INDEX
}

input DataTransformationExpressionInput {
  name: String
  variable: String
  operation: Match
  value: String
  next: String
}

type DataTransformationExpressionOutput {
  name: String
  variable: String
  operation: Match
  value: String
}

input DataTransformationStepInput {
  id: String
  source: String
  outputField: String
  expressions: [DataTransformationExpressionInput]
  next: String
  maxItems: Int
  logic: LogicType
  limitStrategy: LimitStrategy
  fields: [String]
  aggregateFields: [AggregateFieldInput]
  splitOutStrategy: SplitOutStrategy
  aggregateStrategy: AggregateStrategy
  aggregateFieldsStrategy: AggregateFieldsStrategy
  mergeStrategy: MergeStrategy
  sources: [String]
  numberOfSources: Int
}

type DataTransformationStepOutput {
  source: String
  outputField: String
  expressions: [DataTransformationExpressionOutput]
  maxItems: Int
  logic: LogicType
  fields: [String]
  aggregateFields: [AggregateFieldOutput]
  limitStrategy: LimitStrategy
  splitOutStrategy: SplitOutStrategy
  aggregateStrategy: AggregateStrategy
  aggregateFieldsStrategy: AggregateFieldsStrategy
  mergeStrategy: MergeStrategy
  sources: [String]
  numberOfSources: Int
}

type DataTypeEntity {
  id: ID
  clientId: String
  name: String
  version: String
  type: String @deprecated(reason: "Use tags instead")
  jsonSchema: JSON @deprecated(reason: "Use dataModel instead")
  uiSchema: JSON

  """JSON Schema for the data model"""
  dataModel: JSON

  """Image URL for the data model"""
  imageUrl: String

  """Created by the community or not"""
  isCommunityCreated: Boolean!

  """Readonly. If data model is used in an API, it can't be modified"""
  isReadOnly: Boolean!
  preview: ModelPreview
  groupId: String
  relatedDataModels(first: Int = 10, after: String = ""): DataModelConnection
  createdAt: DateTime
  updatedAt: DateTime
}

input DataTypeInput {
  name: String!
  clientId: String
  type: String
  version: String!
  jsonSchema: JSON
  uiSchema: JSON
  groupId: String
  isCommunityCreated: Boolean
}

"""A slightly refined version of RFC-3339 compliant DateTime Scalar"""
scalar DateTime

enum DbActions {
  CREATE
  DELETE
  UPDATE
  GET
}

type DbConnectionEdge {
  cursor: String!
  node: DbConnectionOutput!
}

type DbConnectionOutput {
  id: String
  name: String
  clientId: String!
  type: DbTypes
  config: ConnectConfigOutput
  createdAt: DateTime
  updatedAt: DateTime
}

type DbConnections {
  edges: [DbConnectionEdge!]!
  pageInfo: PageInfo!
}

input DbCreateConnectInput {
  name: String
  clientId: String!
  type: DbTypes
  config: ConnectConfigInput
}

enum DbCreationActionType {
  API
  DATA_SOURCE
}

input DbDataSources {
  connectionId: String
  clientId: String
  tableName: String
  name: String!
  actionType: DbCreationActionType
  actions: [DbActions]
}

enum DbTypes {
  POSTGRES
  INTERNAL
}

input DbUpdateConnectInput {
  id: String!
  name: String
  clientId: String!
  type: DbTypes
  config: ConnectConfigInput
}

input DeactivateConnectorInput {
  projectId: String!
  connectorId: String!
  tenantId: String
  connectionId: String
}

type DeleteEntityOutput {
  clientId: String
  id: String
}

input DeleteEnvConfigurationInput {
  clientId: String!
  key: String!
}

input DeleteFlowTemplateInput {
  id: String!
  orgId: String
}

input DeleteInput {
  id: String!
  appId: String!
  withResources: Boolean
  resourceActionType: ResourceActionType
}

input DeleteLabelInput {
  id: String!
  clientId: String!
  orgId: String
  type: LabelType!
}

input DeleteModelGroupInput {
  clientId: String!
  connectorId: String!
  groupId: String!
}

type DeleteModelGroupOutput {
  clientId: String!
  connectorId: String!
}

input DeleteRecordInput {
  clientId: String!
  tableName: String!
  keyValues: [KeyValInput]!
}

input DeleteTeamMemberInput {
  userId: String!
  teamId: String!
}

input DeleteTemplateInput {
  id: String
  groupId: String!
  clientId: String!
}

input DeleteUserInput {
  userId: String
  organizationId: String!
  role: String!
  teamId: String
}

input DeleteWebhookRouteInput {
  id: String!
  appId: String!
  routeId: String!
}

type DependencySchemaOutput {
  schema: String
}

input DeployApiInput {
  clientId: String!
  id: String!

  """Any deployment comment"""
  comment: String
}

input DesignChatInput {
  message: String!
  chatId: String!
}

type DesignChatOutput {
  message: String!
  chatId: String!
  useCases: [String]
}

input DownLoadFileInput {
  next: String
  source: String!
  contentType: String!
  destinationName: String!
  headers: [HeaderInput]
}

type DownLoadFileOutput {
  next: String
  source: String
  contentType: String
  destinationName: String
  headers: [HeaderOutput]
}

input DuplicateApiDraftInput {
  clientId: String!
  name: String!
  newName: String!
}

input EnableEscapeInFlowInput {
  id: String!
  clientId: String!
  autoEscape: FlowAutoEscape
}

input EnableWorkspaceDeletionInput {
  id: String!
  status: Boolean
}

input EndLoopingStepInput {
  next: String
}

type EndLoopingStepOutput {
  next: String
}

input EnvConfigsListInput {
  env: String!
  data: JSON
}

input EnvConfigurationInput {
  env: String!
  value: String!
}

type EnvConfigurationsOutput {
  clientId: String!
  configurations: [ConfigurationsOutput]
}

input EventSubscriptionInput {
  clientId: String!
  name: String!
  apiKeyId: String
  model: UpdatedDataTypeInput
  webhookId: String
  webhookType: WebhookType
  dlqConfigurations: DLQConfigurationInput
  sqsConfigurations: SqsConfigurationInput
  isAuthenticated: Boolean
  resourceActionType: ResourceActionType
}

type EventSubscriptionOutput {
  id: ID!
  clientId: String!
  name: String
  apiKeyId: String!
  triggerUrl: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  stats: WebhookStats!
  routes: [WebhookRoutesOutput]
  model: DataTypeEntity
  dlqConfigurations: DLQConfigurationOutput
  sqsConfigurations: SqsConfigurationOutput
  isDlq: Boolean
  schedules: [ScheduleOutput]
  isAuthenticated: Boolean
  api_key: String
  webhookType: WebhookType
  deleted: Boolean
}

input ExampleForSchemaInput {
  mockId: String
  mockName: String
  schema: String!
  clientId: String!
}

input ExecuteSqlInput {
  projectId: String!
  query: String!
  context: JSON
  execute: Boolean
}

type ExecutionHistoryOutput {
  error: String
  output: String
  stepsHistories: [StepHistory]
}

input ExportApiKeysInput {
  projectId: String!
  tenantId: String
  ids: [String!]
}

input ExportApisInput {
  projectId: String!
  stage: String!
  ids: [String!]
  limit: Int
  offset: Int
}

input ExportConnectorsGroupInput {
  projectId: String!
  orgId: String
  dataSourceIds: [String!]
  groupIds: [String!]
}

""" --- Build API --- Start ---"""
input ExportDeployedApisInput {
  projectId: String!
  stage: String!
}

input ExportEnvConfigurationsInput {
  projectId: String!
  envs: [String!]
  keys: [String!]
}

input ExportModelsInput {
  projectId: String!
  ids: [String!]
  limit: Int
  offset: Int
}

input ExportProjectResourcesInput {
  projectId: String!
  apisStage: String
  limit: Int
  offset: Int
}

type ExportProjectResourcesOutput {
  connectors: JSON
  apis: JSON
  models: JSON
  templates: JSON
  webhooks: JSON
  widgetConnectors: JSON
}

input ExportTemplatesInput {
  projectId: String
  orgId: String
  ids: [String!]
}

input ExportWebhooksInput {
  projectId: String!
  ids: [String!]
  limit: Int
  offset: Int
}

input ExportWidgetConnectorsInput {
  projectId: String!
  ids: [String!]
  limit: Int
  offset: Int
}

enum FailureBehavior {
  FAILURE
  CONTINUE
}

type FeatureFlagOutput {
  clientId: String!
  features: JSON!
}

input FeaturesFlagInput {
  syndication: Boolean = false
  codegen: Boolean = false
  notifications: Boolean = false
  apiKey: Boolean = true
  invite: Boolean = true
  proxy: Boolean = false
  dataSources: Boolean = false
  models: Boolean = true
  workflow: Boolean = false
  api: Boolean = true
  playground: Boolean = false
  monitor: Boolean = true
  api_design: Boolean = false
  api_review: Boolean = false
  project_setting: Boolean = true
  includeDataSources: Boolean = false
  monetize: Boolean = false
  apiCaching: Boolean = false
  mapperForm: Boolean = false
  beta: Boolean = false
  enableRateLimit: Boolean = true
  webhooksSqs: Boolean = false
  enableCreateOrg: Boolean = false
  fastndb: Boolean = false
  longRunningLambdaFunction: Boolean = false
  useFastnTriggers: Boolean = false
  useTrashFeature: Boolean = false
}

type FieldMetadataOutput {
  keyPath: String
  keyVariable: String
  keyPathWithPrefix: String
  type: String
  label: String
}

type FieldSchemaOutput {
  name: String
  output: String
}

type FieldsOutput {
  name: String
  parentType: String
  output: OutputTypeOutput
  input: InputTypeOutput
  template: ModelTemplateOutput
  dataSource: JSON
  resolver: ConnectPrimaryResolverOutput
}

input FilterInput {
  name: String
  type: String
  status: String
}

input FilterTemplateTypeInput {
  type: DataSourceTemplatePatternType
}

enum FlowAutoEscape {
  MANUAL
  AUTO
}

input FlowChangesLogInput {
  clientId: String
  flowId: String
  version: String
  limit: Int
}

type FlowChangesLogOutput {
  id: String
  workspace_id: String
  env: String
  flow_id: String
  action: String
  time: String
  step_id: String
  version: String
}

enum FlowExecutionType {
  API
  WORKFLOW
  CONFIGURED
}

enum FlowInvocationMethod {
  API_REQUEST
  SCHEDULED_EXECUTION
  APP_EVENT
  WEBHOOK_EVENT
  CHAT_MESSAGE
}

type FlowTemplateListOutput {
  clientId: String!
}

type FlowTemplatesOutput {
  id: String!
  title: String!
  description: String!
  type: FlowType
  uiId: String!
  flowId: String
  labels: [LabelOutput]
}

input FlowTenantSettingsInput {
  enableMultiConfigs: Boolean
  flow: String
  stepId: String
  version: String
  configurationIds: String
}

type FlowTenantSettingsOutput {
  flow: String
  stepId: String
  version: String
  configurationIds: String
  enableMultiConfigs: Boolean
}

enum FlowType {
  API
  WORKFLOW
  CONFIGURATION
}

input FtpStepInput {
  next: String
  path: String
  oldPath: String
  newPath: String
  content: String
  operation: String
  createDirectories: Boolean
  removeDirectories: Boolean
  recursive: Boolean
  useCredentials: Boolean
  credentials: String
  useFtps: Boolean
}

type FtpStepOutput {
  next: String
  path: String
  oldPath: String
  newPath: String
  content: String
  operation: String
  createDirectories: Boolean
  removeDirectories: Boolean
  recursive: Boolean
  useCredentials: Boolean
  credentials: String
  useFtps: Boolean
}

input FunctionInvocationInput {
  clientId: String!
  name: String!
  input: JSON
}

input FunctionStepConfigurationAuthInput {
  identifier: String
  enableMultiConnection: Boolean
  isWorkspaceIdentifier: Boolean
}

type FunctionStepConfigurationAuthOutput {
  identifier: String
  enableMultiConnection: Boolean
  isWorkspaceIdentifier: Boolean
}

input FunctionStepConfigurationInput {
  enableCache: Boolean
  cacheTtlInSeconds: Int
  required: Boolean
  validate: Boolean
  enableRetry: Boolean
  enableAuth: Boolean
  retry: FunctionStepConfigurationRetryInput
  auth: FunctionStepConfigurationAuthInput
  authType: AuthType
  requestSetting: FunctionStepRequestInput
}

type FunctionStepConfigurationOutput {
  enableCache: Boolean
  cacheTtlInSeconds: Int
  required: Boolean
  validate: Boolean
  enableRetry: Boolean
  enableAuth: Boolean
  auth: FunctionStepConfigurationAuthOutput
  authType: AuthType
  retry: FunctionStepConfigurationRetryOutput
  requestSetting: FunctionStepRequestOutput
}

input FunctionStepConfigurationRetryConfigInput {
  delayMilliseconds: Int
  statusCode: Int
  body: String
}

type FunctionStepConfigurationRetryConfigOutput {
  delayMilliseconds: Int
  statusCode: Int
  body: String
}

input FunctionStepConfigurationRetryInput {
  maxRetries: Int
  maxDelayMilliseconds: Int
  enableConnectionErrors: Boolean
  retryList: [FunctionStepConfigurationRetryConfigInput]
}

type FunctionStepConfigurationRetryOutput {
  maxRetries: Int
  maxDelayMilliseconds: Int
  enableConnectionErrors: Boolean
  retryList: [FunctionStepConfigurationRetryConfigOutput]
}

input FunctionStepInput {
  id: ID!
  groupId: String
  name: String
  version: String
  connectorId: String
  imageUrl: String
  configuration: FunctionStepConfigurationInput
  next: String
}

type FunctionStepOutput {
  id: ID!
  groupId: String
  connectorId: String
  name: String
  version: String
  imageUrl: String
  configuration: FunctionStepConfigurationOutput
  next: String
}

input FunctionStepRequestInput {
  connectTimeoutInMilli: Int
  readTimeoutInMilli: Int
  writeTimeoutInMilli: Int
  turnOffSslVerification: Boolean
}

type FunctionStepRequestOutput {
  connectTimeoutInMilli: Int
  readTimeoutInMilli: Int
  writeTimeoutInMilli: Int
  turnOffSslVerification: Boolean
}

input GenerateFlowChatbotInput {
  projectId: String!
  prompt: String!
}

input GenerateLoopItemSchemaInput {
  schema: String
  schemaExample: JSON
  loopOver: String
}

type GenerateLoopItemSchemaOutput {
  schema: JSON
}

input GenerateMapperInput {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
  sourceSchema: JSON
  targetSchema: JSON!
  mapperType: String!
  instructions: String
  mapperCode: String
}

type GenerateMapperOutput {
  data: String
  status: String
}

input GenerateMappingStepInput {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
  outputSchema: String
}

type GeneratedDataType {
  requestDataType: JSON
  successResponseDataType: JSON
  errorResponseDataType: JSON
}

input GeneratedDataTypeInput {
  name: String
  clientId: String
  jsonObject: JSON
}

""" Connectors"""
input GetConnectorInput {
  id: String!
  projectId: String!
  tenantId: String
  template: Boolean
  resourceActionType: ResourceActionType
}

input GetConnectorsListInput {
  projectId: String!
  tenantId: String
  onlyActive: Boolean
  environment: String
  deleted: Boolean
}

input GetEntityInput {
  clientId: String!
  id: String!
  connectorId: String
  environment: String
  tenantId: String
  resourceActionType: ResourceActionType
  refreshCache: Boolean
}

input GetJsonInDatastoreInput {
  id: String!
  clientId: String!
  name: String!
}

input GetListInput {
  clientId: String
}

input GetProjectConfigurationInput {
  projectId: String!
}

input GetProxyLocationInput {
  id: String
  endpoint: String
}

input GetProxyRequestInput {
  clientId: String!
  proxyId: String!
  id: String!
}

""" Database"""
input GetRecordsInput {
  clientId: String!
  tableName: String!
  limit: Int
  offset: Int
  filters: [RecordInput]
  order: String
}

input GetTenantConfigurationsInput {
  clientId: String!
  tenantId: String!
  id: String!
  flowId: String
  stepId: String
  connectorId: String!
  widgetConnectorId: String!
  environment: String
}

type GivenApiOutput {
  uri: UriOutput!
  method: HttpMethod!
  headers: [HeaderOutput]!
  body: String
}

input GivenInput {
  api: ApiInput!
}

type GivenOutput {
  api: GivenApiOutput!
}

type GraphQlPreviewOutput {
  schema: String
  query: String
  response: String
  request: String
  mockEndpoint: String
}

type GroupsOutput {
  id: String!
  clientId: String!
  name: String
  imageUrl: String
  type: DataModelType!
  description: String
  docLink: String
  tags: [String]
  isOauth: Boolean
  oauth: JSON
  oauthInputContract: JSON
  enableActivate: Boolean
  resourceType: ResourceType
  labels: [String]
  activateStatus: ConnectorStatus
  authMethods: [ConnectorAuthMethod]
  authAttributes: JSON
  isPrimary: Boolean
  inputValidation: JSON
  deleted: Boolean
}

type GroupsSearchConnection {
  edges: [GroupsSearchEdge!]!
  pageInfo: PageInfo!
}

type GroupsSearchEdge {
  cursor: String!
  node: GroupsOutput!
}

input GrpcReflectionInput {
  clientId: String!
  target: String!
}

input HeaderInput {
  key: String
  value: String
}

type HeaderOutput {
  key: String
  value: String
}

input HeaderSchemaInput {
  key: String!
  schema: JSON
}

enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  PATCH
}

type HttpResponseOutput {
  """ FIXME RequestType is a duplicate, need to fix it"""
  statusCode: Int!
  contentType: ContentTypeOutput!
  body: String
  headers: JSON
}

enum ImportAction {
  SKIP
  OVERWRITE
}

""" --- Build API --- End ---"""
input ImportApiInput {
  clientId: String!
  name: String!
  data: JSON!
}

input ImportApiKeysInput {
  projectId: String!
  apiKeys: JSON!
}

input ImportApiTemplateBatchInput {
  flowName: String!
  templateId: String!
  deployTo: String
  organizationId: String
  action: ImportAction
}

input ImportApiTemplateInput {
  clientId: String!
  name: String!
  templateId: String!
  deployTo: String
  type: FlowType
  orgId: String
}

input ImportApiTemplatesBatchInput {
  clientId: String!
  templates: [ImportApiTemplateBatchInput]!
}

input ImportApisInput {
  projectId: String!
  sourceProjectId: String!
  apis: JSON!
  stage: String
  orgId: String
  sourceOrgId: String
}

input ImportCollectionInput {
  collection: String!
  clientId: String!
  version: String
  env: String
  collectionType: ImportCollectionType
  collectionLanguage: String
  execute: Boolean
  templateHeaders: Boolean
  templateBody: Boolean
  templateQueryParams: Boolean
  connectorId: String!
  groupId: String!
}

enum ImportCollectionType {
  POSTMAN
  SWAGGER
}

input ImportConnectorGroupInput {
  projectId: String!
  group: JSON
  connectors: JSON
}

input ImportConnectorsResourcesInput {
  projectId: String!
  orgId: String
  sourceProjectId: String!
  connectors: JSON
}

input ImportDataSourceInput {
  id: ID!
  clientId: String!
  name: String!
  description: String
  category: String
  logo: String
  host: String!
  uri: String!
  method: HttpMethod!
  headers: [HeaderInput]!
  body: String
  query: String
  params: [ParamInput]!
  testCaseId: String
  enabled: Boolean!
  testCaseSuite: TestCasesInput
  requestDataType: UpdatedDataTypeInput
  responseDataType: UpdatedDataTypeInput
  responsesSchema: [ResponseSchemaInput]
  isPaginated: Boolean
  pagination: PaginationInput
}

input ImportEnvConfigurationsInput {
  projectId: String!
  configs: JSON
}

input ImportInput {
  clientId: String!
  dataSource: ImportDataSourceInput
}

input ImportModelsInput {
  projectId: String!
  models: JSON
}

type ImportOutPut {
  clientId: String!
  dataSource: DataSourcePayload
}

input ImportProjectResourcesInput {
  projectId: String!
  connectors: JSON
  apis: JSON
  models: JSON
  templates: JSON
  webhooks: JSON
  widgetConnectors: JSON
}

input ImportTemplatesInput {
  projectId: String
  orgId: String
  templates: JSON
}

input ImportWebhooksInput {
  projectId: String!
  webhooks: JSON!
}

input ImportWidgetConnectorsInput {
  projectId: String!
  widgetConnectors: JSON
  limit: Int
  offset: Int
}

input IncludeToCommunityInput {
  groupId: String!
  clientId: String!
  dataSources: [String!]
}

input InlineStepInput {
  code: String
  language: Language!
  fields: [ResolverFieldInput!]
  next: String
  outputSchema: String
  uiCode: String
  hasResponse: Boolean
  isError: Boolean
  statusCode: Int
}

type InlineStepOutput {
  code: String
  language: Language!
  fields: [ResolverFieldOutput!]
  next: String
  uiCode: String
  outputSchema: String
  hasResponse: Boolean
  isError: Boolean
  statusCode: Int
}

input InputOutputSchemaInput {
  input: JSON
  output: JSON
}

input InputTypeInput {
  name: String
  type: String
  schema: String
}

type InputTypeOutput {
  name: String
  type: String
  schema: String
}

input InternalDatabaseStepInput {
  next: String
  query: String
  dbQueryParams: [DBQueryParamInput]
}

type InternalDatabaseStepOutput {
  next: String
  query: String
  dbQueryParams: [DBQueryParamOutput]
}

input InviteTeamInput {
  subgroupId: String!
  projectId: String!
  role: String
}

input InviteUserInput {
  email: String!
  role: String!
  organizationId: String!
  userName: String
}

input InviteUserToPlatformInput {
  email: String!
  firstName: String!
  lastName: String!
}

type InviteUserToPlatformOutput {
  email: String!
  firstName: String!
  lastName: String!
}

input InviteUserToTeamInput {
  email: String!
  teamId: String!
}

input InvokeConnectorActionInput {
  projectId: String
  tenantId: String
  connectorId: String!
  orgId: String!
  refresh: Boolean
  connectorActionId: String!
  payload: JSON
  requestSetting: FunctionStepRequestInput
}

input InvokeCustomAuthFlowInput {
  projectId: String!
  tenantId: String!
  customAuthContext: String
}

input InvokeDataSourceTemplateInput {
  clientId: String!
  input: JSON
  datasource: DataSourceTemplatePatternInput
  requestSettings: FunctionStepRequestInput
}

type InvokeStepOutput {
  data: JSON
  error: String
  memory: String
  executionLogs: [RequestStepOutput]
}

"""A JSON scalar"""
scalar JSON

type JsonInDatastore {
  id: String
  clientId: String
  name: String
  data: String
}

input JsonSchemaInput {
  clientId: String
  name: String
  queryType: QueryType! = QUERY
  output: String
  outputName: String = "output"
  input: String
  inputName: String = "input"
}

input JustId {
  id: String!
}

input KeyValInput {
  key: String
  value: String
}

type KeyValue {
  key: String!
  value: String
}

type LabelOutput {
  id: String!
  clientId: String!
  orgId: String
  name: String!
  type: LabelType
}

enum LabelType {
  FLOW
  TEMPLATE
  CONNECTOR
  WIDGET
}

type LabeledImage {
  label: String!
  imageUrl: String
}

type LabelsConnection {
  edges: [LabelsEdge!]!
  pageInfo: PageInfo!
}

type LabelsEdge {
  cursor: String!
  node: LabelOutput!
}

input LambdaFunctionInput {
  next: String
  code: String
  language: Language
}

type LambdaFunctionOutput {
  next: String
  code: String
  language: Language
}

enum Language {
  JAVASCRIPT
  JINJA
  PYTHON
  C_SHARP
}

input LdTemplatedValueInput {
  code: String!
  activatedLanguage: Language!
}

type LdTemplatedValueOutput {
  code: String!
  activatedLanguage: Language!
}

enum LimitStrategy {
  FIRST
  LAST
}

input ListJsonDataListInput {
  clientId: String
  id: String
}

input ListProxyRequestInput {
  clientId: String!
  proxyId: String!
}

input LoggerStepInput {
  next: String
  message: String
  context: String
}

type LoggerStepOutput {
  next: String
  message: String
  context: String
}

enum LogicType {
  AND
  OR
}

input LoopStepInput {
  steps: [ApiResolverStepInput!]!
  next: String
  start: String
  loopOver: String
  type: LoopingType
  itemSchema: String
  isParallel: Boolean
  loopSize: String
  loopStart: String
}

type LoopStepOutput {
  steps: [ApiResolverStepOutput!]!
  next: String
  start: String
  type: LoopingType
  loopOver: String
  itemSchema: String
  isParallel: Boolean
  loopSize: String
  loopStart: String
}

enum LoopingType {
  DATA
  INFINITY
  FIXED_SIZE
}

enum Match {
  EQ
  NEQ
  EXISTS
  NOT_EXISTS
  GREATER_THAN
  GREATER_THAN_OR_EQ
  LESS_THAN
  LESS_THAN_OR_EQ
  STARTS_WITH
  ENDS_WITH
  CONTAINS
  DOES_NOT_CONTAIN
  DOES_NOT_START_WITH
  DOES_NOT_END_WITH
  TYPE_OF
  MATCHES_REGEX
  DOES_NOT_MATCH_REGEX
  LENGTH_EQ
  NONE
  EQ_IGNORE_CASE
}

input McpClientStepInput {
  next: String
  sseUrl: String
  authKey: String
  authValue: String
  authType: AuthMethod
  toolIncluded: ToolIncluded
  tools: [McpClientToolInput]
  resourceType: ResourceType
}

type McpClientStepOutput {
  next: String
  sseUrl: String
  authKey: String
  authValue: String
  authType: AuthMethod
  toolIncluded: ToolIncluded
  tools: [McpClientToolOutput]
  resourceType: ResourceType
}

input McpClientToolInput {
  id: String
  name: String
  description: String
  parameters: String
}

type McpClientToolOutput {
  id: String
  name: String
  description: String
  parameters: String
}

input McpClientToolsInput {
  clientId: String!
  sseUrl: String
  resourceType: ResourceType
}

enum MergeStrategy {
  APPEND
  COMBINE
}

enum MigrateActionActionInput {
  DELETE_LOGS
  MIGRATE_SECRETS
  LIST_PROJECTS
  MIGRATE_ORG_COMMUNITY_LABELS
  MIGRATE_FLOWS_LABELS
  MIGRATE_COMMUNITY_TEMPLATE
  MIGRATE_ORGS_TEMPLATE
  INIT_PLATFORM
}

input MigrateActionInput {
  action: MigrateActionActionInput
}

input ModelFieldInput {
  name: String
  parentType: String
  output: OutputTypeInput
  input: InputTypeInput
  template: ModelTemplateInput
  dataSource: JSON
}

type ModelPreview {
  json: String
  graphql: String
}

type ModelSchemaOutput {
  id: ID!
  name: String!
  description: String
  version: String
  queryType: QueryType
  model: JSON
  input: JSON
  inputName: String

  """Action type for the API."""
  actionType: ApiActionType

  """
  GraphQL schema associated with the model
  Temp. This would be generated automatically later
  """
  schema: String
  remote: RemoteOutput
  types: [TypesOutput]
  tests: [ApiTestCaseInputOutput]
}

input ModelTemplateInput {
  type: String
  data: JSON
}

type ModelTemplateOutput {
  type: String
  data: JSON
}

input ModelTypeInput {
  name: String!
  fields: [ModelFieldInput]
}

input MultiConnectorWidgetConnectorInput {
  name: String!
  connectionId: String!
  id: String!
}

type Mutation {
  buildRestApi(input: RestDataSourceSpecInput): RestApiOutput
  registerWebhook(input: EventSubscriptionInput): EventSubscriptionOutput
  registerEventSubscription(input: EventSubscriptionInput): EventSubscriptionOutput
  updateWebhook(input: UpdateWebhookInput): EventSubscriptionOutput
  deleteWebhook(input: DeleteInput): EventSubscriptionOutput
  deleteAppTrigger(input: DeleteInput): AppTriggerOutput
  createWebhookRoute(input: CreateWebhookRouteInput): CreateWebhookRouteOutput
  updateWebhookRoute(input: CreateWebhookRouteInput): CreateWebhookRouteOutput
  deleteWebhookRoute(input: DeleteWebhookRouteInput): CreateWebhookRouteOutput
  createWebhookSchedule(input: CreateWebhookScheduleInput): EventSubscriptionOutput
  updateWebhookSchedule(input: CreateWebhookScheduleInput): EventSubscriptionOutput
  registerWebhookWithRoutes(input: CreateWebhookWithRoutsInput): EventSubscriptionOutput
  registerWebhookWithRoutesBatch(input: CreateWebhooksWithRoutsBatchInput): [EventSubscriptionOutput]
  executeSchedule(input: ScheduleActionInput): JSON
  terminateWorkFlowJob(input: ScheduleActionInput): JSON
  triggerWebhookFlow(input: TriggerWebhookFlowInput!): AppTriggerOutput
  createAppTrigger(input: CreateAppTriggerInput!): AppTriggerOutput
  updateAppTrigger(input: UpdateAppTriggerInput!): AppTriggerOutput
  addFlowTemplate(input: AddFlowTemplateInput!): FlowTemplateListOutput
  updateFlowTemplate(input: AddFlowTemplateInput!): FlowTemplateListOutput
  deleteFlowTemplate(input: DeleteFlowTemplateInput!): FlowTemplatesOutput
  importApiTemplate(input: ImportApiTemplateInput!): ApiOutput
  importApiTemplateToExistFlow(input: importApiTemplateToExistFlowInput!): ApiOutput
  importFlowTemplatesBatch(input: ImportApiTemplatesBatchInput!): [ApiOutput]
  createLabel(input: CreateLabelInput!): LabelOutput
  updateLabel(input: UpdateLabelInput!): LabelOutput
  deleteLabel(input: DeleteLabelInput!): LabelOutput
  createModelSchema(input: CreateModelSchemaInput!): JSON
  updateModelSchema(input: UpdateModelSchemaInput!): JSON
  deployModelSchema(input: GetEntityInput!): ModelSchemaOutput
  deleteModelSchema(input: GetEntityInput!): JSON
  createModelSchemaV2(input: CreateModelSchemaInput!): ModelSchemaOutput
  updateModelSchemaV2(input: UpdateModelSchemaInput!): ModelSchemaOutput
  runApiTestCase(input: ApiTestCaseInput): ApiTestCaseOutput
  buildApi(input: ApiBuildInput!): ApiOutput
  buildApiDraft(input: BuildApiDraftInput!): BuildApiDraftOutput
  duplicateApiDraft(input: DuplicateApiDraftInput!): BuildApiDraftOutput
  deployApi(input: GetEntityInput!): ApiOutput
  updateBuildApi(input: ApiUpdateBuildInput!): ApiOutput
  updateApiMetaData(input: UpdateApiMetaDataInput!): UpdateApiMetaDataOutput
  publishApi(input: GetEntityInput!): ApiOutput
  deployApiToStage(input: deployApiToStageInput!): ApiOutput
  connectPrimaryResolver(input: ApiConnectPrimaryResolverInput!): ConnectPrimaryResolverOutput
  invokePrimaryResolver(input: ApiPrimaryResolverInvocationInput!): InvokeStepOutput
  connectSecondaryResolver(input: ApiConnectSecondaryResolverInput!): ConnectPrimaryResolverOutput
  addApiTests(input: AddApiTestsInput): [ApiTestCaseInputOutput]
  addApiDependency(input: AddApiDependencyInput!): AddApiDependencyOutput
  updateApiDependency(input: AddApiDependencyInput!): AddApiDependencyOutput
  removeApiDependency(input: RemoveApiDependencyInput!): RemoveApiDependencyOutput
  cloneResolverStep(input: CloneResolverStep!): ApiResolverStepOutput
  updateStepSkipStatus(input: UpdateStepSkipStatus!): ApiResolverStepOutput
  createResolverStep(input: CreateResolverStepInput!): ApiResolverStepOutput
  updateResolverStep(input: CreateResolverStepInput!): ApiResolverStepOutput
  deleteResolverStep(input: StepInputSchemaInput!): connectResolverStepsOutput
  connectResolverSteps(input: ConnectResolverStepsInput!): connectResolverStepsOutput
  disconnectResolverSteps(input: ConnectResolverStepsInput!): connectResolverStepsOutput
  importApi(input: ImportApiInput!): ApiOutput

  """  --- Copilot API ---"""
  generateFlowChatbot(input: GenerateFlowChatbotInput!): JSON
  resetAiAgentContext(input: ProjectInput!): JSON
  queryGeneration(input: GenerateFlowChatbotInput!): JSON
  enableEscapeInFlow(input: EnableEscapeInFlowInput): ApiOutput
  createAppTriggerEvents(input: AppTriggerEventsInput!): AppTriggerEventsOutput
  updateAppTriggerEvents(input: AppTriggerEventsInput!): AppTriggerEventsOutput
  deleteAppTriggerEvents(input: GetEntityInput!): AppTriggerEventsOutput
  createSecret(input: SecretsDataInput!): SecretsDataOutput
  updateSecret(input: SecretsDataInput!): SecretsDataOutput
  deleteSecret(clientId: String!, secretKey: String!, discriminator: String): SecretsDataOutput
  createEnvConfiguration(input: [CreateEnvConfigurationInput]): EnvConfigurationsOutput
  updateEnvConfiguration(input: [CreateEnvConfigurationInput]): EnvConfigurationsOutput
  deleteEnvConfiguration(input: DeleteEnvConfigurationInput): EnvConfigurationsOutput
  createEnv(input: ProjectEnvInput): ProjectEnvOutput
  deleteEnv(input: ProjectEnvInput): ProjectEnvOutput
  createSecrets(input: CreateSecretsInput!): SecretsDataOutput
  createEnvConfigs(input: CreateEnvConfigsInput): EnvConfigurationsOutput
  createTenant(input: TenantSecretInput!): TenantSecretOutput
  updateTenant(input: TenantSecretInput!): TenantSecretOutput
  deleteTenant(input: GetEntityInput!): TenantSecretOutput
  migrateSecrets(input: MigrateActionInput!): JSON
  initPlatform(input: MigrateActionInput!): JSON
  configureTenantFlow(input: ConfigureTenantFlowInput!): ApiOutput
  deleteTenantConfiguration(input: GetEntityInput!): ApiOutput
  createTenantConfiguration(input: TenantConfigurationsInput!): TenantConfigurationOutput
  enableTenantConfiguration(input: TenantConfigurationsInput!): TenantConfigurationOutput
  updateTenantConfiguration(input: TenantConfigurationsInput!): TenantConfigurationOutput
  deleteTenantConfig(input: GetTenantConfigurationsInput!): TenantConfigurationOutput
  disableTenantConfig(input: GetTenantConfigurationsInput!): TenantConfigurationOutput
  deleteTenantEventSubscription(input: GetEntityInput): AppTriggerOutput
  addOrganization(name: String, id: String): Organization
  enableWorkSpaceDelete(input: EnableWorkspaceDeletionInput!): Organization
  createApp(name: String, id: String): ApplicationOutput
  generateApiKeyForOrganization(input: ApiKeyInput!): ApiKey!
  generateMcpApiKeyForOrganization(organizationId: String): ApiKey
  updateApiKey(input: ApiKeyInput!): ApiKey!
  removeAPIKeyForOrganization(id: String!, organizationId: String!): ApiKey!
  updatePaymentStatusForOrganization(organizationId: String!, paymentStatus: String!, paymentReferenceId: String!): Organization!
  renameOrganization(id: String!, name: String!): Organization!
  deleteOrganization(id: String!): OrganizationId
  updateProjectConfiguration(input: UpdateProjectConfigurationInput!): ProjectConfiguration
  sendAccountInformation(input: SendAccountInput): sendAccountOutput
  createTeam(input: CreateTeamInput!): Organization
  deleteTeam(input: GetEntityInput!): Organization
  inviteTeamToProject(input: InviteTeamInput!): Organization
  inviteUserToOrg(userId: String!, orgId: String!, role: AccessRole): JSON
  removeUserFromOrg(userId: String!, orgId: String!): JSON
  removeRootAdmin(userId: String!): JSON

  """ Import resources mutations"""
  importConnectors(input: ImportConnectorsResourcesInput): JSON
  importApis(input: ImportApisInput): JSON
  importWidgetConnectors(input: ImportWidgetConnectorsInput): JSON
  importModels(input: ImportModelsInput): JSON
  importTemplates(input: ImportTemplatesInput): JSON
  importWebhooks(input: ImportWebhooksInput): JSON
  importEnvConfigurations(input: ImportEnvConfigurationsInput): JSON
  importApiKeys(input: ImportApiKeysInput): JSON
  createProxy(input: CreateProxyInput!): ProxyOutput
  updateProxy(input: UpdateProxyInput!): ProxyOutput
  deleteProxy(input: GetEntityInput!): DeleteEntityOutput
  buildApiFromProxyRequest(input: buildApiFromProxyRequestInput): ApiOutput
  CreateDataType(input: DataTypeInput!): DataTypeEntity @deprecated(reason: "Use createDataModel instead")
  createDataModel(input: DataTypeInput!): DataTypeEntity
  createCommunityDataModel(input: CommunityDataTypeInput!): DataTypeEntity
  UpdateDataType(input: UpdatedDataTypeInput): DataTypeEntity @deprecated(reason: "Use updateDataModel instead")
  updateDataModel(input: UpdatedDataTypeInput): DataTypeEntity
  deleteDataType(input: GetEntityInput!): DataTypeEntity @deprecated(reason: "Use deleteDataModel instead")
  deleteDataModel(input: GetEntityInput!): DataTypeEntity
  generateDataTypeFromJson(input: GeneratedDataTypeInput!): DataTypeEntity
  addRelatedDataModels(input: RelatedDataModelsInput): RelatedDataModelsOutput
  cloneDataModel(input: CloneDataModelInput): DataTypeEntity
  buildJsonSchema(input: BuildJsonSchemaInput): BuildJsonSchemaOutput
  createDbApis(input: DbDataSources): [ApiOutput]
  createInternalDbApis(input: DbDataSources): [ApiOutput]
  createDbConnection(input: DbCreateConnectInput): DbConnectionOutput
  updateDbConnection(input: DbUpdateConnectInput): DbConnectionOutput
  deleteDbConnection(input: GetEntityInput!): DbConnectionOutput

  """ Database"""
  createTable(input: TableInfoInput!): TableInfo!
  addRecords(input: AddRecordsInput!): JSON
  removeTable(input: GetEntityInput!): String
  deleteRecord(input: DeleteRecordInput!): JSON
  executeSqlQuery(input: ExecuteSqlInput!): JSON
  createConnector(input: CreateConnectorInput!): Connector
  updateConnector(input: UpdateConnectorInput!): Connector
  deleteConnector(input: GetEntityInput!): Connector
  deployWidgetConnector(input: GetEntityInput!): Connector
  saveWidgetConnectorStatus(input: SaveWidgetConnectorStatusInput!): ConnectorStatus
  saveWidgetConnectorsStyles(input: WidgetConnectorsStylesInput!): WidgetConnectorsStyles
  saveActivateConnectorState(input: ActivateConnectorStateInput!): KeyValue
  saveWidgetMetadata(input: SaveWidgetMetadataInput!): WidgetMetadata
  deactivateConnector(input: DeactivateConnectorInput!): JSON
  createDataSourceTemplate(input: DataSourceTemplatePatternInput): DataSourceTemplatePattOutput
  updateDataSourceTemplate(input: DataSourceTemplatePatternInput): DataSourceTemplatePattOutput
  updateDataSourceTemplateMetadata(input: UpdateDataSourceTemplatePatternMetadataInput): DataSourceTemplatePattOutput
  deleteDataSourceTemplate(input: GetEntityInput): DeleteEntityOutput
  deleteTemplateWithGroupConnection(input: DeleteTemplateInput!): DeleteEntityOutput
  publishDataSourceTemplate(input: GetEntityInput): DataSourceTemplatePattOutput
  addDataSourceToGroup(input: AddDataSourceToGroupInput): AddDataSourceToGroupOutput
  includeToCommunity(input: IncludeToCommunityInput): [DataSourceTemplatePattOutput]
  importCollection(input: ImportCollectionInput): JSON
  updateDataSourceTemplateLabels(input: UpdateDataSourceTemplateLabels): DataSourceTemplatePattOutput
  saveJsonInDatastore(input: SaveJsonInDatastore): JsonInDatastore
  deleteJsonFromDatastore(input: GetJsonInDatastoreInput): JsonInDatastore
  createSyndication(input: CreateSyndicationInput!): SyndicationOutput
  updateSyndication(input: UpdateSyndicationInput!): SyndicationOutput
  deleteSyndication(input: GetEntityInput!): SyndicationOutput
  syndicate(input: GetEntityInput!): SyndicationOutput
  createWorkflow(input: CreateWorkflowInput): WorkflowOutput @deprecated(reason: "Use buildWorkflow instead. This will be removed and doesn't allow deployment")

  """Builds a workflow"""
  buildWorkflow(input: CreateWorkflowInput): WorkflowOutput

  """Deploys a workflow"""
  deployWorkflow(input: GetEntityInput): WorkflowOutput
  deleteWorkflow(input: GetEntityInput): DeleteEntityOutput
  updateWorkflow(input: UpdateWorkflowInput): WorkflowOutput
  updateWorkflowMetadata(input: UpdateWorkflowMetadataInput): WorkflowMetadataOutput
  runTestCases(input: RunTestCaseInput): TestCaseOutPut

  """
  DataSource.
  Templates for a datasource can only be applied on:
  * Hosts
  * URL
  * Headers (duplication of keys would replace headers)
  """
  createDataSource(input: CreateDataSourceInput!): CreateDataSourceOutput
  updateDataSource(input: UpdateDataSourceInput!): UpdateDataSourceOutput
  deleteDataSource(input: GetEntityInput): DataSourcePayload
  testDataSource(input: TestDataSourceInput!): JSON
  importDataSource(input: ImportInput!): ImportOutPut

  """Response when you test the data source."""
  testEndPoint(input: TestDataSourceInput): DataSourceTestPayload
  testIndexStore(input: TestDataSourceInput): DataSourceTestPayload
  deleteUserForOrganization(user: DeleteUserInput): OrgUserType
  inviteUserToOrganization(user: InviteUserInput!): OrgUserType
  updateUserInfo(userProfileInput: userProfileInfo): UserProfile
  addUserToTeam(input: InviteUserToTeamInput!): OrgUserType
  deleteUserFromTeam(input: DeleteTeamMemberInput!): OrgUserType
  inviteUserToPlatform(input: InviteUserToPlatformInput!): InviteUserToPlatformOutput
  assignRoleToUser(input: AssignRoleToUserInput!): OrgUserType
  createOnboarding(id: String!): String
  createFeatures(input: CreateInputInput!): JSON! @deprecated(reason: "Use configurePlatform instead")
  configurePlatform(input: CreateInputInput!): JSON!
  createUserFeatures(input: CreateUserFeaturesInput!): JSON! @deprecated(reason: "Use configurePlatform instead")
  createModelGroup(input: CreateModelGroupInput): GroupsOutput
  updateModelGroup(input: UpdateModelGroupInput): GroupsOutput
  deleteModelGroup(input: DeleteModelGroupInput): DeleteModelGroupOutput
  saveLogsMetadata(input: GetEntityInput!): SaveLogsMetadataOutput
  saveApplicationLogs(input: SaveApplicationLogsInput!): JSON
}

type OrgUserType {
  id: String!
  email: String!
  userName: String!
  name: String!
  role: String!
  isDeletable: Boolean
  invitationStatus: String
  teamId: String
}

type Organization {
  id: String
  name: String
  paymentStatus: String
  paymentReferenceId: String
  role: String
  lagoKey: String
  email: String
  packageType: SubscriptionPackages
  parentTeam: String
  orgId: String
  deletable: Boolean
}

type OrganizationId {
  id: String
}

input OrganizationInput {
  id: String!
  name: String
}

input OutputTypeInput {
  type: String
  schema: String
}

type OutputTypeOutput {
  type: String
  schema: String
}

type PageInfo {
  "    Previous page and start cursor is not supported yet.\n    hasPreviousPage: Boolean!\n    startCursor: String"
  hasNextPage: Boolean!
  endCursor: String
  pages: Int
  totalCount: Int
  currentCount: Int
}

input PaginatedListInput {
  clientId: String!

  """Hard limit of 10"""
  first: Int! = 10
  after: String
}

input PaginationInput {
  type: String
  limit: HeaderInput
  offset: HeaderInput
  termination: HeaderInput
  responsePath: String
}

type PaginationOutput {
  type: String
  limit: HeaderOutput
  offset: HeaderOutput
  termination: HeaderOutput
  responsePath: String
}

input ParamInput {
  key: String!
  value: String!
}

type ParamOutput {
  key: String
  value: String
}

type PostgresTablesContent {
  name: String
  schema: String
}

enum PriorityLevel {
  URGENT
  HIGH
  MEDIUM
  LOW
}

type ProductOutput {
  title: String
}

type ProjectConfiguration {
  projectId: String!
  features: JSON!
  packageType: SubscriptionPackages!
  customPlan: CustomPlan
  rateLimiter: RateLimiterOutput
  dbConnection: DbConnectionOutput
}

input ProjectEnvInput {
  clientId: String!
  env: String!
}

type ProjectEnvOutput {
  clientId: String!
  env: String!
  isDeletable: Boolean
}

input ProjectInput {
  projectId: String!
}

input ProxyInput {
  urlSuffix: String!
  headers: [HeaderInput]!
  params: [ParamInput]
}

type ProxyOperationOutput {
  name: String
  schema: String
}

type ProxyOutput {
  id: String!
  clientId: String!
  name: String
  version: String!
  description: String
  logo: String
  url: String
  proxyUrl: String
  registeredApis: [String]
  requests: [ProxyRequestOutput]
  variables: JSON
  additionalInfo: JSON
}

type ProxyRequestOutput {
  id: String!
  clientId: String
  proxyId: String
  operationName: String
  body: String
  headers: [KeyValue]
  url: String

  """Returns the schema for this operation"""
  operationSchema: String
  isConnected: Boolean
  outputSchema: JSON
}

type Query {
  restApi(input: GetEntityInput): RestApiOutput
  webhooks(input: SearchDataModelInput!): WebhookConnection
  webhook(input: GetEntityInput): EventSubscriptionOutput
  appTriggers(input: SearchDataModelInput!): AppTriggersConnection
  appTrigger(input: GetEntityInput!): AppTriggerOutput
  apiTemplates: [FlowTemplatesOutput]
  listTemplates(input: SearchDataModelInput!): [FlowTemplatesOutput]
  listLabels(input: SearchDataModelInput!): LabelsConnection
  modelSchema(input: GetEntityInput): JSON @deprecated(reason: "Use modelSchemaV2 instead")
  modelSchemaV2(input: GetEntityInput): ModelSchemaOutput
  modelSchemas(input: GetListInput!): [JSON]
  generateApiTestCase(input: GetEntityInput): [ApiTestCaseInputOutput]
  api(input: GetEntityInput): ApiOutput
  apis(input: SearchDataModelInput!): ApiConnection
  selectionFlows(input: SearchDataModelInput!): ApiConnection
  configurationFlows(input: SearchDataModelInput!): ApiConnection
  apiDeploymentHistory(input: SearchDeployedApis!): ApiConnection
  flowByVersion(input: deployApiToStageInput!): ApiOutput
  apiPreview(input: ApiPreviewInput!): ApiPreviewOutput
  apiAutocomplete(input: ApiAutocompleteInput!): [String]
  typesInSchema(input: SchemaStringInput): [TypesOutput]
  testConnector(input: TestConnectorInput!): HttpResponseOutput! @deprecated(reason: "Use connectorRequest instead")
  connectorRequest(input: TestConnectorInput!): HttpResponseOutput!
  supportedLanguages: SupportedLanguages
  summary(input: GetListInput!): SummaryOutput!
  exampleForSchema(input: ExampleForSchemaInput): SchemaExampleOutput
  compile(input: CompileInput!): JSON
  invokeInlineFunction(input: CompileInput!): InvokeStepOutput
  designChat(input: DesignChatInput!): DesignChatOutput
  reviewApiDesign(input: ReviewDesignInput!): ReviewDesignOutput
  generateMapper(input: GenerateMapperInput!): GenerateMapperOutput
  executeCurl(input: CurlRequestInput!): CurlOutput
  apiDependencies(input: GetEntityInput!): ApiDependencyList
  stepInputSchema(input: StepInputSchemaInput!): StepInputSchemaOutput
  generateMapperSchema(input: StepInputSchemaInput!): GenerateLoopItemSchemaOutput
  generateMappingForStep(input: GenerateMappingStepInput!): GenerateMapperOutput
  generateLoopItemSchema(input: GenerateLoopItemSchemaInput): GenerateLoopItemSchemaOutput
  exportApi(input: GetEntityInput): JSON
  getAiAgentContext(input: ProjectInput!): JSON
  exportFlowsSwagger(input: ExportApisInput!): JSON
  executeGetFieldDataFlow(input: ApiPrimaryResolverInvocationInput!): InvokeStepOutput
  invokeCustomAuthFlow(input: InvokeCustomAuthFlowInput): JSON
  mcpClientTools(input: McpClientToolsInput!): JSON
  listAppTriggers(input: SearchDataModelInput!): AppTriggerEventsConnection
  triggerEvents(input: GetEntityInput!): AppTriggerEventsOutput
  getSecrets(clientId: String!, hide: Boolean, discriminator: String): SecretsDataOutput
  getEnvs(input: GetListInput): [ProjectEnvOutput]
  getEnvConfigurations(input: GetListInput): EnvConfigurationsOutput
  getTenants(input: SearchDataModelInput!): TenantConnection
  tenantFlow(input: GetEntityInput!): ApiOutput
  tenantFlows(input: SearchDataModelInput!): ApiConnection
  tenantConfigurationsBasedOnConnector(input: SearchDataModelInput!): TenantConfigurationsConnection
  tenantConfigurationsById(input: GetTenantConfigurationsInput): TenantConfigurationOutput
  getConfigurationSubscription(input: ConfigurationSubscriptionInput): [ConfigurationSubscription]
  connectorConnection(input: ConnectorConnectionInput): JSON
  invokeConnectorAction(input: InvokeConnectorActionInput): JSON
  appTriggerAccounts(input: AppTriggerAccountsInput!): AppTriggerAccountsOutput
  tenantEventSubscriptions(input: SearchDataModelInput): [AppTriggerOutput]
  getOrganization(id: String!): Organization
  getOrganizations(userId: String): [Organization]
  getApiKeyForOrganization(id: String, organizationId: String): ApiKey
  getProjectConfiguration(input: GetProjectConfigurationInput!): ProjectConfiguration
  listApiKeysForOrganization(organizationId: String, discriminator: String): [ApiKey]
  listApiKeys(input: SearchDataModelInput!): ApiKeysConnection
  getTeams(input: GetListInput!): [Organization]
  getTeamMembers(input: GetEntityInput!): [User]

  """ Export resources queries"""
  exportConnectors(input: ExportConnectorsGroupInput!): JSON
  exportApis(input: ExportApisInput): JSON
  exportModels(input: ExportModelsInput): JSON
  exportTemplates(input: ExportTemplatesInput): JSON
  exportWebhooks(input: ExportWebhooksInput): JSON
  exportWidgetConnectors(input: ExportWidgetConnectorsInput): JSON
  exportEnvConfigurations(input: ExportEnvConfigurationsInput): JSON
  exportApiKeys(input: ExportApiKeysInput!): JSON
  listOrgUsers(orgId: String!): [OrgUserType]
  listRootAdmins: [OrgUserType]
  proxy(input: GetEntityInput!): ProxyOutput
  proxies(input: GetListInput!): [ProxyOutput]
  proxyRequests(input: ListProxyRequestInput!): [ProxyRequestOutput]
  proxyRequest(input: GetProxyRequestInput!): ProxyRequestOutput
  filter(input: String): String
  invoke(input: FunctionInvocationInput): JSON
  testFunction(input: TestFunctionInput): JSON
  getDataType(input: GetEntityInput): DataTypeEntity @deprecated(reason: "Use dataModel instead")
  dataModel(input: GetEntityInput): DataTypeEntity
  getDataTypes(input: GetListInput!): [DataTypeEntity] @deprecated(reason: "Use dataModels instead")
  dataModels(input: PaginatedListInput!): DataModelConnection
  dataModelByGroup(input: DataModelByGroupInput!): DataModelConnection
  getApiInput(input: RecommendedModelInput): [RecommendedModelOutput]
  dataModelPreview(input: DataModelPreviewInput!): ModelPreview
  product(id: String): ProductOutput
  dbConnection(input: GetEntityInput!): DbConnectionOutput
  dbConnections(input: SearchDataModelInput!): DbConnections
  connectDb(input: ConnectDbInput): ConnectDbOutput
  testConnection(input: ConnectConfigInput): ConnectDbOutput

  """   Database"""
  getTables(clientId: String!): JSON
  getRecords(input: GetRecordsInput): JSON
  getTableSchema(input: GetRecordsInput): JSON
  connectors(input: GetConnectorsListInput!): [Connector]
  widgetConnectorStatus(input: WidgetConnectorStatusInput!): WidgetConnectorStatus
  widgetConnectors(input: WidgetConnectorsInput!): WidgetConnectors
  connector(input: GetConnectorInput!): Connector
  widgetConnectorStyles(input: GetConnectorsListInput!): WidgetConnectorsStyles
  activateConnectorState(input: KeyValInput): ActivateConnectorStateOutput
  widgetMetadata(input: GetEntityInput!): WidgetMetadata

  """Test datasource by providing the id, and the variables."""
  testDataSourceTemplate(input: TestDataSourceTemplateInput!): JSON
  invokeDataSourceTemplate(input: InvokeDataSourceTemplateInput!): JSON
  searchDataSourceTemplates(input: SearchTemplateInput!): [DataSourceTemplate!]!
  dataSourceTemplate(input: GetEntityInput!): DataSourceTemplatePattOutput
  dataSourceByGroup(input: DataModelByGroupInput!): DataSourceTemplateConnection
  inputSchemaFromDataSourceTemplate(input: InvokeDataSourceTemplateInput!): JSON
  exportConnectorsSwagger(input: ExportConnectorsGroupInput): JSON
  fetchGrpcReflection(input: GrpcReflectionInput!): JSON

  """
  Build a graphQL schema by passing json schema.
  Returned schema is validated.
  
  NOTE: This is a beta feature and is subject to change.
  WARNING:
  * Required json schema properties are ignored
  * Only a single query is built
  """
  buildSchema(input: JsonSchemaInput): SchemaInfoOutput

  """
  Retrieve a list of all templates available, with pagination, sorting and filtering options.
  """
  searchDataModelTemplates(input: SearchInput!): [DataModelTemplate!]!
  listJsonInDatastore(input: ListJsonDataListInput): [JsonInDatastore]
  getJsonInDatastore(input: GetJsonInDatastoreInput): JsonInDatastore
  syndication(input: GetEntityInput!): SyndicationOutput
  syndicationList(input: GetListInput!): [SyndicationOutput]
  workflow(input: GetEntityInput!): WorkflowOutput
  workflows(input: GetListInput!): [WorkflowOutput]!
  invokeWorkflow(input: WorkflowInvocationInput!): String
  getTestCases(input: GetEntityInput!): TestCaseOutPut
  dataSources(input: GetListInput!): DataSourceConnection

  """
  Returns the data source. If the data source does not exist, the response is null.
  """
  dataSource(input: GetEntityInput): DataSourcePayload
  testCases(input: GetEntityInput!): TestCaseOutPut
  getUser(id: String!): User
  getUsers(filters: UserFiltersInput): [User]
  getUsersForOrganization(organizationId: String!): [OrgUserType]
  getUserInfo(id: String!): UserProfile
  dashboardStats(input: GetEntityInput!): dashboardOutputData
  features(input: GetListInput!): JSON!
  allConnectionsTypes(input: SearchDataModelInput): [allConnectionsTypesOutput]
  searchDataModels(input: SearchDataModelInput!): GroupsSearchConnection
  searchDataSourceGroups(input: SearchDataModelInput!): GroupsSearchConnection
  getGroup(input: GetEntityInput!): GroupsOutput
  activateConnectorRedirectInfo: JSON
  requestContext(input: GetEntityInput!): RequestLogOutput
  requestMonitors(input: GetListInput!): [RequestLogOutput]!
  requestLog(input: GetEntityInput!): RequestLogOutput
  requestLogs(input: SearchDataModelInput!): RequestLogConnection
  requestLogsStatusCodes(input: GetListInput!): JSON
  logsMetadata(input: GetListInput!): SaveLogsMetadataOutput
  flowChangesLog(input: FlowChangesLogInput!): [FlowChangesLogOutput]
}

enum QueryType {
  QUERY
  MUTATION
}

input RateLimiterInput {
  timeoutDuration: Int
  limitRefreshPeriod: Int
  limitForPeriod: Int
}

type RateLimiterOutput {
  timeoutDuration: Int
  limitRefreshPeriod: Int
  limitForPeriod: Int
}

enum RecommendationType {
  MODEL
  GROUP
}

input RecommendedModelInput {
  operation: ApiActionType
  output: String!
  apiName: String!
}

type RecommendedModelOutput {
  id: String
  name: String
  imageUrl: String
  type: RecommendationType
}

input RecordInput {
  key: String!
  value: String!
  operator: String!
}

input RelatedDataModelsInput {
  modelId: String!
  relatedModelId: String!
}

type RelatedDataModelsOutput {
  modelId: String!
  relatedModelId: String!
}

input RemoteInput {
  isProxy: Boolean
  template: ModelTemplateInput
  dataSource: JSON
  graphql: String
  dataSourceDependencies: [ConditionalDataSourceInput]
}

type RemoteOutput {
  isProxy: Boolean
  template: ModelTemplateOutput
  dataSource: JSON
  graphql: String
  dataSourceDependencies: [JSON]
  types: [JSON]
}

input RemoveApiDependencyInput {
  id: String!
  clientId: String!
  dependencyId: String!
}

""" updateApiMetadataInput  Schema --- End ---"""
type RemoveApiDependencyOutput {
  id: String!
  clientId: String!
  dependencyId: String!
}

type Request {
  clientId: String!
  name: String!
  host: String!
  uri: String!
  method: HttpMethod!
  description: String
  headers: [HeaderOutput]!
  body: String
  query: String
  params: [ParamOutput]

  """Variable values"""
  template: TestCaseTemplate!
}

input RequestInput {
  clientId: String!
  name: String!
  host: String!
  uri: String!
  method: HttpMethod!
  description: String
  headers: [HeaderInput]!
  body: String
  query: String
  params: [ParamInput]

  """Variable values"""
  template: TestCaseTemplateInput!
  proxy: ProxyInput
}

type RequestLogConnection {
  edges: [RequestLogEdge!]!
  pageInfo: PageInfo!
}

type RequestLogEdge {
  cursor: String!
  node: RequestLogOutput!
}

type RequestLogMessageOutput {
  message: String!
  context: JSON
  label: String
  timestamp: DateTime!
}

type RequestLogOutput {
  id: ID!
  client: String!
  requestType: RequestType
  startAt: DateTime!
  endAt: DateTime!
  label: String!
  logs: [RequestLogMessageOutput!]
  steps: [RequestStepOutput]!
  stepStatuses: JSON
  code: Int
  reason: String
  tenantId: String
  webhookScheduleId: String
  workflowJobId: String
  clientProjectId: String
}

type RequestResponse {
  """ Replace with HttpResponseOutput"""
  body: JSON
  statusCode: Int
}

type RequestStepOutput {
  id: ID
  name: String!
  start: DateTime!
  end: DateTime!
  duration: Int
}

enum RequestType {
  GRAPHQL_INTEGRATION
  REST_INTEGRATION
  GRAPHQL_API
  REST_API
  PROXY_REQUEST
}

input ResolverFieldInput {
  name: String!
  resolver: ApiConnectPrimaryResolverInput
}

type ResolverFieldOutput {
  name: String!
  resolver: ConnectPrimaryResolverOutput
}

enum ResourceActionType {
  TRASH
  RESTORE
  DELETE
}

enum ResourceType {
  INTERNAL
  INTERNAL_EXPOSE
  EXTERNAL
}

input ResponseAndRequestContent {
  contentType: ContentTypeOutput
  headers: [HeaderSchemaInput]
  example: JSON
  schema: JSON
  schemaSourceType: SchemaSourceType = JSON_SCHEMA
}

type ResponseSchema {
  code: Int
  model: DataTypeEntity
  example: JSON
}

input ResponseSchemaInput {
  code: Int
  model: UpdatedDataTypeInput
}

" returns an id\n contract test URL\n generated test case\n open api documentation\n relevant datasources\n output schema\n example of output schema\n input schema\n example of input schema"
type RestApiOutput {
  clientId: ID!
  id: ID!
  mockUrl: String!
}

input RestDataSourceSpecInput {
  clientId: ID!
  name: String!
  description: String
  version: String
  remote: RemoteInput
  dataSource: ApiSchemaInput
  type: DataSourceSpecInputType
  value: String
}

type RestPreviewOutput {
  schema: String
}

type ReviewDesign {
  rule: String!
  examples: [String]
  recommendations: [String]
}

input ReviewDesignInput {
  api: String!
}

type ReviewDesignOutput {
  reviews: [ReviewDesign]
}

input RunTestCaseInput {
  testedSinkId: String
  testCasePayload: testCasePayload
}

enum SCHEMA_TYPE {
  JSON
}

input SaveApplicationLogsInput {
  type: ApplicationType!
  logs: [String!]
}

input SaveJsonInDatastore {
  id: String!
  name: String!
  clientId: String!
  data: String!
}

type SaveLogsMetadataOutput {
  clientId: String
  id: String
  logsApi: String
  saveLogsApi: String
  updateLogsApi: String
  count: Int
}

input SaveWidgetConnectorStatusInput {
  projectId: String!
  connectorId: String!
  tenantId: String
  checkSecret: Boolean
  isDependencyConnector: Boolean
  connections: [String!]
}

input SaveWidgetMetadataInput {
  projectId: String!
  styles: String
  authenticationApi: String
  isCustomAuthenticationEnabled: Boolean
  showFilterBar: Boolean
  disableFor: [String!]
  filterWidgets: Boolean
  isRBACEnabled: Boolean
  isAIAgentWidgetEnabled: Boolean
  showLabels: Boolean
}

input ScheduleActionInput {
  clientId: String!
  webhookId: String
  scheduleId: String
  jobId: String
  logId: String
}

input ScheduleBatchInput {
  name: String
  flowId: String!
  payload: String
  payloadJson: JSON
  type: ScheduleType!
  enable: Boolean!
  schedulerDelayInMin: Int
  rate: ScheduleRateInput
  cron: ScheduleCronInput
  flowHeaders: [HeaderInput]
}

input ScheduleCronInput {
  minutes: String
  hours: String
  dayOfMonth: String
  month: String
  dayOfWeek: String
  year: String
}

type ScheduleCronOutput {
  minutes: String
  hours: String
  dayOfMonth: String
  month: String
  dayOfWeek: String
  year: String
}

input ScheduleInput {
  name: String
  apiId: String!
  payload: String
  payloadJson: JSON
  type: ScheduleType!
  enable: Boolean!
  schedulerDelayInMin: Int
  rate: ScheduleRateInput
  cron: ScheduleCronInput
  headers: [HeaderInput]
}

type ScheduleOutput {
  id: String
  name: String
  apiId: String!
  payload: String
  type: ScheduleType!
  enable: Boolean!
  schedulerDelayInMin: Int
  rate: ScheduleRateOutput
  cron: ScheduleCronOutput
  headers: [HeaderOutput]
  stats: WebhookScheduleStatsOutput
}

input ScheduleRateInput {
  unit: ScheduleRateUnitInput
  value: Int
  unitTime: ScheduleRateUnitInput
  time: Int
}

type ScheduleRateOutput {
  unit: ScheduleRateUnitInput
  value: Int
}

enum ScheduleRateUnitInput {
  days
  minutes
  hours
  day
  minute
  hour
}

enum ScheduleType {
  rate
  cron
}

type SchemaExampleOutput {
  example: JSON
}

type SchemaInfoOutput {
  """Requesting client's id"""
  clientId: String

  """Name of the schema. Same as the graphql query name"""
  name: String

  """GraphQL schema with an operation added"""
  schema: String

  """
  A sample query, with the input fields filled, and all
  output fields requested
  """
  query: String

  """URL to test this query on"""
  testUrl: String

  """An example response to the query with all fields filled in"""
  example: String
}

enum SchemaSourceType {
  JSON_SCHEMA
  JSON_EXAMPLE
}

input SchemaStringInput {
  schema: String!
}

input SearchDataModelInput {
  clientId: String!
  first: Int! = 10
  after: String
  query: String
  orgId: String
  connectorId: String
  tenantId: String
  offset: Int
  deleted: Boolean
  isCommunity: Boolean
  discriminator: String
  expired: Boolean
  allowedTenant: String
  searchTerm: String
}

input SearchDeployedApis {
  clientId: String!
  id: String!
  first: Int! = 10
  after: String
  env: String
}

input SearchInput {
  query: String
}

input SearchTemplateInput {
  clientId: String

  """ make it required later"""
  query: String
  filter: FilterTemplateTypeInput
}

input SecretsDataInput {
  clientId: String!
  secretKey: String!
  secretValue: String!
  discriminator: String
  connections: [String!]
}

type SecretsDataOutput {
  clientId: String!
  secretKeys: [String!]!
  success: Boolean!
  message: String!
}

input SecretsInput {
  secretKey: String!
  secretValue: JSON!
  connections: [String!]
}

input SendAccountInput {
  email: String!
  password: String!
}

enum ShowWidgetConnectorActions {
  ALWAYS
  WHEN_ACTIVE
  WHEN_INACTIVE
  WHEN_INACTIVE_AND_CONFIGURED
  WHEN_ACTIVE_AND_CONFIGURED
  WHEN_INACTIVE_AND_NOT_CONFIGURED
  WHEN_ACTIVE_AND_NOT_CONFIGURED
}

input SimpleExpressionInput {
  """When no path is sent, the entire response is tested"""
  field: ApiField!
  path: String
  match: Match!
  expected: String!
}

type SimpleExpressionOutput {
  """When no path is sent, the entire response is tested"""
  field: ApiField!
  path: String
  match: Match!
  expected: String!
}

enum SkipStatus {
  SKIP
  UNSKIP
}

enum SplitOutStrategy {
  INCLUDES_ONLY
  EXCLUDES_ONLY
}

input SqsConfigurationInput {
  accessPrinciple: String
  isEnabled: Boolean
}

type SqsConfigurationOutput {
  accessPrinciple: String
  isEnabled: Boolean
  sqsArn: String
  sqsUrl: String
}

type StarterAction {
  name: String
  href: String
}

input StarterActionInput {
  name: String!
  href: String!
}

enum StateAction {
  READ
  OVERWRITE
  APPEND
}

enum StateOutput {
  DRAFT
  DEPLOYED
}

input StateStepInput {
  next: String
  code: String
  uiCode: String!
  stateKey: String
  stateAction: StateAction
}

type StateStepOutput {
  next: String
  code: String
  uiCode: String
  stateKey: String
  stateAction: StateAction
}

type StepHistory {
  name: String
  input: String
  output: String
  status: SyndicationExecutionStatus
  startedAt: DateTime
  endedAt: DateTime
}

input StepInputSchemaInput {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
  uiCode: String
}

type StepInputSchemaOutput {
  schema: String
  options: [String]
  optionsWithPrefix: [String]
  example: String
  sourceFields: [FieldMetadataOutput]
}

type StepSetting {
  failureBehavior: FailureBehavior
  errorMessage: String
  stepNote: String
  skipStatus: SkipStatus
}

input StepSettingInput {
  failureBehavior: FailureBehavior
  errorMessage: String
  skipStatus: SkipStatus
  stepNote: String
}

enum StepType {
  FUNCTION
  API
  DB
  TASK
  PARALLEL
  CONDITIONAL
  WAIT
  INLINE
  COMPOSITE
  StepType
  LOOP
  ENDLOOP
  VARIABLE
  LOGGER
  INTERNAL_DB
  CONVERTER
  DOWNLOAD_FILE
  LAMBDA
  STATE
  TRIGGER
  FILTER
  LIMIT
  SPLIT_OUT
  AGGREGATE
  MERGE
  AI_ACTION
  AI_AGENT
  MCP_CLIENT
  FTP
}

type StepValidation {
  fieldValidation: Boolean
  submitValidation: Boolean
  modelId: String
  jsonSchema: String
  submitValidationFunction: String
}

input StepValidationInput {
  fieldValidation: Boolean
  submitValidation: Boolean
  modelId: String
  jsonSchema: String
  submitValidationFunction: String
}

enum StorageLocation {
  IN_MEMORY
  ON_DISK
}

enum SubscriptionPackages {
  FREE
  TEAM
  PRO
  ENTERPRISE
}

type SummaryOutput {
  dashboard: DashboardOutput
}

type SupportedLanguage {
  language: Language!
  label: String
  starterCode: String
  examples: [CodeExample]
}

type SupportedLanguages {
  languages: [SupportedLanguage!]!
}

type SupportedOperation {
  name: String!
  description: String
  input: JSON
}

type SyndicationConfiguration {
  syndicationDataSources: [SyndicationDataSources]
}

input SyndicationConfigurationInput {
  syndicationDataSources: [SyndicationDataSourcesInput]
}

type SyndicationDataSources {
  datasourceId: String
  transformation: String
}

input SyndicationDataSourcesInput {
  datasourceId: String
  transformation: String
}

type SyndicationExecutionOutput {
  id: ID!
  total: Int
  errors: Int
  message: String
  status: SyndicationExecutionStatus
  startedAt: DateTime
  sourceId: String
  executionHistory: ExecutionHistoryOutput
}

enum SyndicationExecutionStatus {
  PARTIAL_SUCCESS
  SUCCESS
  FAILED
  RUNNING
  PENDING
  CANCELLED
}

type SyndicationOutput {
  id: ID!
  clientId: String!
  name: String!
  description: String
  indexName: String
  entityName: String
  syndicationConfiguration: SyndicationConfiguration
  sinkDatasourceId: String
  transformation: LdTemplatedValueOutput
  additionalInfo: JSON
  lastExecution: SyndicationExecutionOutput
  executions(first: Int = 0, after: String = ""): [SyndicationExecutionOutput]
}

type TableInfo {
  clientId: String!
  name: String!
  description: String
  columns: [ColumnInfo!]!
}

input TableInfoInput {
  clientId: String!
  name: String!
  description: String
  override: Boolean
  columns: [ColumnInfoInput!]!
}

input TemplateLabels {
  id: String!
  clientId: String!
  orgId: String
  name: String!
  type: LabelType
}

type TenantConfigurationOutput {
  clientId: String!
  tenantId: String!
  id: String!
  uiCode: String!
  flowId: String!
  stepId: String!
  status: ConfigurationSubscriptionStatus
  configurations: JSON
  connector: Connector
  configuredStepSetting: ConfiguredStepSetting
}

type TenantConfigurationsConnection {
  edges: [TenantConfigurationsEdge!]!
  pageInfo: PageInfo!
}

type TenantConfigurationsEdge {
  cursor: String!
  node: TenantConfigurationOutput!
}

input TenantConfigurationsInput {
  clientId: String!
  tenantId: String!
  id: String!
  flowId: String
  stepId: String
  uiCode: String
  active: Boolean
  configurations: JSON
  connectorId: String
}

type TenantConnection {
  edges: [TenantEdge!]!
  pageInfo: PageInfo!
}

type TenantEdge {
  cursor: String!
  node: TenantSecretOutput!
}

input TenantSecretInput {
  clientId: String!
  id: String!
  name: String!
  keys: [String]
  secret: JSON
}

type TenantSecretOutput {
  clientId: String!
  id: String!
  name: String
  keys: [String]
}

type TestCase {
  request: Request
  expected: JSON
  isPass: Boolean
  type: String
}

input TestCaseInput {
  request: RequestInput
  expected: JSON
  isPass: Boolean
  type: String
}

type TestCaseOutPut {
  id: ID
  clientId: String!
  type: String!
  testCases: [TestCase]
}

type TestCaseTemplate {
  context: JSON!
}

input TestCaseTemplateInput {
  context: JSON!
}

input TestCasesInput {
  id: ID
  clientId: String!
  type: String!
  testCases: [TestCaseInput]
}

input TestConnectorInput {
  clientId: String!
  context: String
  dataSource: JSON
}

input TestDataSourceInput {
  clientId: String!
  name: String
  host: String
  uri: String
  method: HttpMethod
  description: String
  headers: [HeaderInput]
  body: String
  query: String
  params: [ParamInput]!

  """Variable values"""
  template: DataSourceTemplateInput
  type: DataSourceType
  index: TestIndexStoreDataSourceInput
  http: TestHttpDataSourceInput
}

input TestDataSourceTemplateInput {
  clientId: String!
  id: String!
  input: JSON
  requestSettings: FunctionStepRequestInput
}

"""
extend type Mutation {
    createFunction(input: CreateFunctionInput): String
    updateFunction(input: CreateFunctionInput): String
    deleteFunction(input: CreateFunctionInput): String
}
"""
input TestFunctionInput {
  clientId: String!
  input: JSON!
  code: String!
}

input TestHttpDataSourceInput {
  clientId: String
  name: String!
  host: String!
  uri: String!
  method: HttpMethod!
  description: String
  headers: [HeaderInput]!
  body: String
  query: String
  params: [ParamInput]

  """Variable values"""
  template: DataSourceTemplateInput!
}

input TestIndexStoreDataSourceInput {
  name: String!
  query: KeyValInput!
  autoComplete: Boolean
  source: JSON
  target: JSON
}

type TestResolverOutput {
  output: String
  input: String
  status: SyndicationExecutionStatus
  startedAt: DateTime
  endedAt: DateTime
  stepsHistories: [StepHistory]
}

enum TestResult {
  SUCCESS
  FAILURE
}

input ThenInput {
  expressions: [SimpleExpressionInput!]!
}

type ThenOutput {
  expressions: [SimpleExpressionOutput!]!
}

enum ToolIncluded {
  ALL
  SELECTED
}

input TriggerStepInput {
  next: String
  connectorName: String
  connectorId: String!
  connectorImage: String
  event: String!
  userAccountId: String!
  headers: [HeaderInput]
}

type TriggerStepOutput {
  next: String
  connectorName: String
  connectorImage: String
  connectorId: String
  event: String
  userAccountId: String
  headers: [HeaderOutput]
}

enum TriggerStepType {
  SUBSCRIBE
  UNSUBSCRIBE
}

input TriggerWebhookFlowInput {
  id: String!
  clientId: String!
  userProjectId: String!
  userAccountId: String!
  flowId: String!
  tenantId: String
  connectorId: String
  event: String
  backendUrl: String
  connectorName: String
  payload: JSON
  headers: [HeaderInput]
}

type TypesOutput {
  name: String!
  fields: [FieldsOutput]
}

input UpdateApiMetaDataInput {
  id: String!
  clientId: String!
  metaData: ApiMetaDataInput!
}

type UpdateApiMetaDataOutput {
  id: String!
  clientId: String!
  metaData: ApiMetaDataOutput!
}

input UpdateAppTriggerInput {
  id: String!
  clientId: String!
  userAccountId: String!
  flowId: String!
  connectorId: String!
  tenantId: String
  event: String!
  connectorName: String
  connectorImage: String
  headers: [HeaderInput]
  type: AppTriggerType
}

input UpdateConnectorInput {
  id: String!
  projectId: String!
  name: String
  description: String
  imageUri: String
  actions: [ConnectorActionInput]
  events: [ConnectorEventInput]
  connectedConnectors: [ConnectedConnectorsInput]
  content: String
  active: Boolean
  tenantScope: [String]
  isTenantScopeEnabled: Boolean
  widgetType: WidgetType
  starterActions: [StarterActionInput!]
  images: [String!]
  dataFlowLabel: DataFlowLabel
  labels: [String]
}

input UpdateDataSourceInput {
  id: ID!
  clientId: String!
  name: String
  description: String
  category: String
  logo: String
  host: String
  uri: String
  method: HttpMethod
  headers: [HeaderInput]
  body: String
  query: String
  params: [ParamInput]
  testCaseId: String
  enabled: Boolean!
  variables: JSON
  type: DataSourceTemplatePatternType
  requestDataType: DataSourceDataTypeInput
  responseDataType: DataSourceDataTypeInput
  responsesSchema: [ResponseSchemaInput]
  isPaginated: Boolean!
  pagination: PaginationInput
}

"""Input for the createDataSource mutation"""
type UpdateDataSourceOutput {
  dataSource: DataSource!
  id: ID!
  clientId: String!
  name: String!
  description: String
  category: String
  logo: String
  host: String!
  uri: String!
  method: HttpMethod!
  headers: [HeaderOutput]!
  body: String
  query: String
  params: [ParamOutput]!
  testCaseId: String
  enabled: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  variables: JSON
  type: DataSourceTemplatePatternType
  requestDataType: DataTypeEntity
  responseDataType: DataTypeEntity
  responsesSchema: [ResponseSchema]
  isPaginated: Boolean!
  pagination: PaginationOutput
}

input UpdateDataSourceTemplateLabels {
  id: String!
  clientId: String!
  connectorId: String!
  groupId: String!
  labels: [String]
}

input UpdateDataSourceTemplatePatternInput {
  id: ID
  clientId: ID!
  name: String!
  contract: DataSourceSpecInput
  contractVariables: [ContractVariableInput]
  isConfiguration: Boolean
  configurationLayer: ConfigurationLayerMapperInput

  """For functions"""
  code: String
  imageUrl: String
  isCommunityCreated: Boolean! = false
  connectionSchemaString: String

  """Datasource type: fn, api, db, etc."""
  type: DataSourceTemplatePatternType
}

input UpdateDataSourceTemplatePatternMetadataInput {
  id: ID
  clientId: ID!
  name: String!
}

input UpdateLabelInput {
  id: String!
  clientId: String!
  orgId: String
  name: String!
  type: LabelType!
}

input UpdateModelGroupInput {
  id: String!
  clientId: String!
  name: String
  imageUrl: String
  type: DataModelType!
  description: String
  docLink: String
  tags: [String]
  isOauth: Boolean
  oauthSecret: String
  oauth: JSON
  oauthInputContract: JSON
  enableActivate: Boolean
  resourceType: ResourceType
  labels: [String]
  authMethods: [ConnectorAuthMethodInput]
}

input UpdateModelSchemaInput {
  clientId: String!
  id: String!
  name: String!
  description: String
  actionType: ApiActionType
  version: String
  model: UpdatedDataTypeInput
  input: UpdatedDataTypeInput
  queryType: QueryType
  inputName: String

  """
  GraphQL schema associated with the model
  Temp. This would be generated automatically later
  """
  schema: String
  remote: RemoteInput
  types: [ModelTypeInput]
  tests: [ApiTestCaseInput]
}

input UpdateProjectConfigurationInput {
  projectId: String!
  features: JSON!
  packageType: SubscriptionPackages!
  customPlan: CustomPlanInput
  rateLimiter: RateLimiterInput
  dbConnection: DbCreateConnectInput
}

input UpdateProxyInput {
  id: String!
  clientId: String!
  name: String
  version: String!
  logo: String
  description: String
  url: String
  proxyUrl: String
  registeredApis: [String]
  introspectionUrl: String
  variables: JSON
  additionalInfo: JSON
}

input UpdateStepSkipStatus {
  id: String!
  clientId: String!
  parentIds: [String]
  nodeId: String
  skipStatus: SkipStatus
}

input UpdateSyndicationInput {
  id: ID!
  clientId: String!
  name: String!
  description: String
  indexName: String
  entityName: String
  syndicationConfiguration: SyndicationConfigurationInput
  sinkDatasourceId: String
  transformation: LdTemplatedValueInput
  additionalInfo: JSON
}

input UpdateWebhookInput {
  id: ID!
  clientId: String!
  name: String
  apiKeyId: String
  model: UpdatedDataTypeInput
  dlqConfigurations: DLQConfigurationInput
  isAuthenticated: Boolean
  webhookType: WebhookType
}

input UpdateWorkflowInput {
  clientId: String!
  id: String!
  name: String!
  description: String
  imageUrl: String
  startStep: String!
  steps: [WorkflowStepInput!]!
  contract: ActionContractInput
}

input UpdateWorkflowMetadataInput {
  clientId: String!
  id: String!
  name: String
  description: String
  imageUrl: String
  contract: ActionContractInput
}

input UpdatedDataTypeInput {
  id: ID
  name: String
  clientId: String
  type: String
  version: String
  jsonSchema: JSON
  uiSchema: JSON
  groupId: String
  isCommunityCreated: Boolean
}

input UriInput {
  """The base uri of the API"""
  uri: String

  """Knexa API id can be used to connect to an API built on knexa"""
  knexaApiId: String
}

type UriOutput {
  """The base uri of the API"""
  uri: String

  """Knexa API id can be used to connect to an API built on knexa"""
  knexaApiId: String
}

type User {
  id: String!
  email: String!
  userName: String!
  name: String!
  role: String!
  subscribedOrganizationsIDs: [String]
  icon: String
  isDeletable: Boolean
  invitationStatus: String
}

input UserFiltersInput {
  firstName: String
}

input UserInput {
  id: String!
  firstName: String
}

type UserProfile {
  id: String
  firstName: String
  lastName: String
  email: String
  phone: String
  image: String
  description: String
  language: String
  country: String
  status: String
  firstLogin: Boolean
  firstProjectId: String
}

enum UserRoles {
  ROOT_ADMIN
  ROOT_MAINTAIN
  ROOT_WRITE
  ROOT_READ
  ADMIN
  MAINTAIN
  WRITE
  READ
}

input VariablesStepInput {
  next: String
  variables: [VariablesStepListInput]
  code: String
  uiCode: String!
}

input VariablesStepListInput {
  key: String
  type: String
  value: String
}

type VariablesStepListOutput {
  key: String
  type: String
  value: String
}

type VariablesStepOutput {
  next: String
  variables: [VariablesStepListOutput]
  code: String
  uiCode: String
}

type WebhookConnection {
  edges: [WebhookEdge!]!
  pageInfo: PageInfo!
}

type WebhookEdge {
  cursor: String!
  node: EventSubscriptionOutput!
}

type WebhookRouteStatsOutput {
  processed: Int!
  pending: Int!
  failed: Int!
  total: Int!
  missed: Int
}

input WebhookRoutesFilterInput {
  patterns: String!
}

type WebhookRoutesFilterOutput {
  patterns: String
}

type WebhookRoutesOutput {
  routeId: String!
  description: String
  apiId: String!
  batchSize: Int
  maximumBatchingWindow: Int
  status: String
  filters: [WebhookRoutesFilterOutput]
  headers: [HeaderOutput]
  stats: WebhookRouteStatsOutput
}

type WebhookScheduleStatsOutput {
  processed: Int!
  pending: Int!
  failed: Int!
  total: Int!
  missed: Int
}

type WebhookStats {
  name: String!

  """ Total number of messages retained"""
  total: Int!
}

enum WebhookType {
  SCHEDULE
  EVENT
  EVENT_SCHEDULE
}

type WidgetConnectorEdge {
  cursor: String
  node: Connector!
}

type WidgetConnectorStatus {
  projectId: String!
  connectorId: String!
  tenantId: String
  status: ConnectorStatus
}

input WidgetConnectorStatusInput {
  projectId: String!
  connectorId: String!
  tenantId: String
  isDependencyConnector: Boolean = false
  connectionId: String
}

type WidgetConnectors {
  edges: [WidgetConnectorEdge!]!
  pageInfo: PageInfo!
}

input WidgetConnectorsInput {
  projectId: String!
  tenantId: String
  first: Int! = 10
  after: String
  deleted: Boolean
  query: String
}

type WidgetConnectorsStyles {
  projectId: String!
  styles: String
}

input WidgetConnectorsStylesInput {
  projectId: String!
  styles: String!
}

type WidgetMetadata {
  styles: String
  authenticationApi: String
  isCustomAuthenticationEnabled: Boolean
  showFilterBar: Boolean
  disableFor: [String!]
  filterFlow: String
  filterWidgets: Boolean
  isRBACEnabled: Boolean
  isAIAgentWidgetEnabled: Boolean
  showLabels: Boolean
}

enum WidgetType {
  CONNECTOR
  STARTER
}

input WorkflowInvocationInput {
  id: String!
  clientId: String!
  input: JSON
}

type WorkflowMetadataOutput {
  clientId: String!
  id: String!
  name: String
  description: String
  imageUrl: String
  contract: ActionContractOutput
}

type WorkflowOutput {
  clientId: String!
  id: String!
  name: String!
  description: String
  imageUrl: String
  inputSchema: String @deprecated(reason: "Use contract instead")
  contract: ActionContractOutput
  startStep: String!
  steps: [WorkflowStepOutput!]!
  executions(first: Int = 0, after: String = ""): [SyndicationExecutionOutput]
  state: StateOutput!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input WorkflowStepInput {
  name: String!
  clientId: String
  imageUrl: String
  description: String
  type: StepType!
  next: String!
  code: String
  codeFn: String
  schema: InputOutputSchemaInput
  end: Boolean!
  variables: JSON
  contract: ActionContractInput
}

type WorkflowStepOutput {
  name: String!
  imageUrl: String
  description: String
  type: StepType!
  next: String!
  codeFn: String
  code: String
  end: Boolean!
  variables: JSON
  contract: ActionContractOutput
}

type allConnectionsTypesOutput {
  id: String!
  clientId: String!
  name: String!
  imageUrl: String
  type: DataModelType!
  description: String
}

input buildApiFromProxyRequestInput {
  clientId: String!
  proxyId: String!
  proxyRequestId: String!
}

type connectResolverStepsOutput {
  id: String
  clientId: String
  source: String
  target: String
}

type dashboardOutputData {
  stats: [dashboardOutputStats]
  connectors: String
  flows: String
  connectorsStats: [ConnectorsStatsData]
}

type dashboardOutputStats {
  label: String
  latency: Float
  latency99: Float
  latency90: Float
  errors: Int
  requests: Int
  startat: String
}

input deployApiToStageInput {
  id: String!
  clientId: String!
  env: String!
  version: String
  comment: String
  revertOnly: Boolean
}

input importApiTemplateToExistFlowInput {
  clientId: String!
  templateId: String!
  deployTo: String
  type: FlowType
  orgId: String
  flowToUpdate: String!
}

type sendAccountOutput {
  email: String!
  password: String!
}

enum status {
  SUCCESS
  ERROR
}

input testCasePayload {
  id: ID
  clientId: String!
  type: String!
  testCases: [TestCaseInput]
}

input userProfileInfo {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String!
  description: String
  image: String
  language: String
  country: String!
  status: String
  firstProjectId: String
}
